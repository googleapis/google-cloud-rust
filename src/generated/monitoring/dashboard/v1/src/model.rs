// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A chart that displays alert policy data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AlertChart {
    /// Required. The resource name of the alert policy. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlertChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AlertChart::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AlertChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.AlertChart"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AlertChart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AlertChart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AlertChart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AlertChart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AlertChart {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AlertChart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AlertChart");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A widget that groups the other widgets. All widgets that are within
/// the area spanned by the grouping widget are considered member widgets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CollapsibleGroup {
    /// The collapsed state of the widget on first page load.
    pub collapsed: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CollapsibleGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [collapsed][crate::model::CollapsibleGroup::collapsed].
    pub fn set_collapsed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.collapsed = v.into();
        self
    }
}

impl wkt::message::Message for CollapsibleGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.CollapsibleGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CollapsibleGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collapsed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CollapsibleGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collapsed" => Ok(__FieldTag::__collapsed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CollapsibleGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CollapsibleGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collapsed => {
                            if !fields.insert(__FieldTag::__collapsed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collapsed",
                                ));
                            }
                            result.collapsed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CollapsibleGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.collapsed) {
            state.serialize_entry("collapsed", &self.collapsed)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CollapsibleGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CollapsibleGroup");
        debug_struct.field("collapsed", &self.collapsed);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes how to combine multiple time series to provide a different view of
/// the data.  Aggregation of time series is done in two steps. First, each time
/// series in the set is _aligned_ to the same time interval boundaries, then the
/// set of time series is optionally _reduced_ in number.
///
/// Alignment consists of applying the `per_series_aligner` operation
/// to each time series after its data has been divided into regular
/// `alignment_period` time intervals. This process takes _all_ of the data
/// points in an alignment period, applies a mathematical transformation such as
/// averaging, minimum, maximum, delta, etc., and converts them into a single
/// data point per period.
///
/// Reduction is when the aligned and transformed time series can optionally be
/// combined, reducing the number of time series through similar mathematical
/// transformations. Reduction involves applying a `cross_series_reducer` to
/// all the time series, optionally sorting the time series into subsets with
/// `group_by_fields`, and applying the reducer to each subset.
///
/// The raw time series data can contain a huge amount of information from
/// multiple sources. Alignment and reduction transforms this mass of data into
/// a more manageable and representative collection of data, for example "the
/// 95% latency across the average of all tasks in a cluster". This
/// representative data can be more easily graphed and comprehended, and the
/// individual time series data is still available for later drilldown. For more
/// details, see [Filtering and
/// aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Aggregation {
    /// The `alignment_period` specifies a time interval, in seconds, that is used
    /// to divide the data in all the
    /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
    /// time. This will be done before the per-series aligner can be applied to
    /// the data.
    ///
    /// The value must be at least 60 seconds. If a per-series aligner other than
    /// `ALIGN_NONE` is specified, this field is required or an error is returned.
    /// If no per-series aligner is specified, or the aligner `ALIGN_NONE` is
    /// specified, then this field is ignored.
    ///
    /// The maximum value of the `alignment_period` is 2 years, or 104 weeks.
    pub alignment_period: std::option::Option<wkt::Duration>,

    /// An `Aligner` describes how to bring the data points in a single
    /// time series into temporal alignment. Except for `ALIGN_NONE`, all
    /// alignments cause all the data points in an `alignment_period` to be
    /// mathematically grouped together, resulting in a single data point for
    /// each `alignment_period` with end timestamp at the end of the period.
    ///
    /// Not all alignment operations may be applied to all time series. The valid
    /// choices depend on the `metric_kind` and `value_type` of the original time
    /// series. Alignment can change the `metric_kind` or the `value_type` of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `cross_series_reducer` is specified, then
    /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
    /// and `alignment_period` must be specified; otherwise, an error is
    /// returned.
    pub per_series_aligner: crate::model::aggregation::Aligner,

    /// The reduction operation to be used to combine time series into a single
    /// time series, where the value of each data point in the resulting series is
    /// a function of all the already aligned values in the input time series.
    ///
    /// Not all reducer operations can be applied to all time series. The valid
    /// choices depend on the `metric_kind` and the `value_type` of the original
    /// time series. Reduction can yield a time series with a different
    /// `metric_kind` or `value_type` than the input time series.
    ///
    /// Time series data must first be aligned (see `per_series_aligner`) in order
    /// to perform cross-time series reduction. If `cross_series_reducer` is
    /// specified, then `per_series_aligner` must be specified, and must not be
    /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
    /// error is returned.
    pub cross_series_reducer: crate::model::aggregation::Reducer,

    /// The set of fields to preserve when `cross_series_reducer` is
    /// specified. The `group_by_fields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// operation. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `cross_series_reducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `group_by_fields` are aggregated away.  If
    /// `group_by_fields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `cross_series_reducer` is not
    /// defined, this field is ignored.
    pub group_by_fields: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Aggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alignment_period][crate::model::Aggregation::alignment_period].
    pub fn set_alignment_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.alignment_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [alignment_period][crate::model::Aggregation::alignment_period].
    pub fn set_or_clear_alignment_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.alignment_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [per_series_aligner][crate::model::Aggregation::per_series_aligner].
    pub fn set_per_series_aligner<T: std::convert::Into<crate::model::aggregation::Aligner>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_series_aligner = v.into();
        self
    }

    /// Sets the value of [cross_series_reducer][crate::model::Aggregation::cross_series_reducer].
    pub fn set_cross_series_reducer<T: std::convert::Into<crate::model::aggregation::Reducer>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_series_reducer = v.into();
        self
    }

    /// Sets the value of [group_by_fields][crate::model::Aggregation::group_by_fields].
    pub fn set_group_by_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.group_by_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Aggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Aggregation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Aggregation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alignment_period,
            __per_series_aligner,
            __cross_series_reducer,
            __group_by_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Aggregation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alignmentPeriod" => Ok(__FieldTag::__alignment_period),
                            "alignment_period" => Ok(__FieldTag::__alignment_period),
                            "perSeriesAligner" => Ok(__FieldTag::__per_series_aligner),
                            "per_series_aligner" => Ok(__FieldTag::__per_series_aligner),
                            "crossSeriesReducer" => Ok(__FieldTag::__cross_series_reducer),
                            "cross_series_reducer" => Ok(__FieldTag::__cross_series_reducer),
                            "groupByFields" => Ok(__FieldTag::__group_by_fields),
                            "group_by_fields" => Ok(__FieldTag::__group_by_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Aggregation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Aggregation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alignment_period => {
                            if !fields.insert(__FieldTag::__alignment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alignment_period",
                                ));
                            }
                            result.alignment_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__per_series_aligner => {
                            if !fields.insert(__FieldTag::__per_series_aligner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for per_series_aligner",
                                ));
                            }
                            result.per_series_aligner = map.next_value::<std::option::Option<crate::model::aggregation::Aligner>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cross_series_reducer => {
                            if !fields.insert(__FieldTag::__cross_series_reducer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_series_reducer",
                                ));
                            }
                            result.cross_series_reducer = map.next_value::<std::option::Option<crate::model::aggregation::Reducer>>()?.unwrap_or_default();
                        }
                        __FieldTag::__group_by_fields => {
                            if !fields.insert(__FieldTag::__group_by_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_by_fields",
                                ));
                            }
                            result.group_by_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Aggregation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.alignment_period.is_some() {
            state.serialize_entry("alignmentPeriod", &self.alignment_period)?;
        }
        if !wkt::internal::is_default(&self.per_series_aligner) {
            state.serialize_entry("perSeriesAligner", &self.per_series_aligner)?;
        }
        if !wkt::internal::is_default(&self.cross_series_reducer) {
            state.serialize_entry("crossSeriesReducer", &self.cross_series_reducer)?;
        }
        if !self.group_by_fields.is_empty() {
            state.serialize_entry("groupByFields", &self.group_by_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Aggregation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Aggregation");
        debug_struct.field("alignment_period", &self.alignment_period);
        debug_struct.field("per_series_aligner", &self.per_series_aligner);
        debug_struct.field("cross_series_reducer", &self.cross_series_reducer);
        debug_struct.field("group_by_fields", &self.group_by_fields);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Aggregation].
pub mod aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// The `Aligner` specifies the operation that will be applied to the data
    /// points in each alignment period in a time series. Except for
    /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
    /// operation replaces the set of data values in each alignment period with
    /// a single value: the result of applying the operation to the data values.
    /// An aligned time series has a single data value at the end of each
    /// `alignment_period`.
    ///
    /// An alignment operation can change the data type of the values, too. For
    /// example, if you apply a counting operation to boolean values, the data
    /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
    /// in the aligned result is `INT64`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Aligner {
        /// No alignment. Raw data is returned. Not valid if cross-series reduction
        /// is requested. The `value_type` of the result is the same as the
        /// `value_type` of the input.
        AlignNone,
        /// Align and convert to
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
        /// The output is `delta = y1 - y0`.
        ///
        /// This alignment is valid for
        /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
        /// `DELTA` metrics. If the selected alignment period results in periods
        /// with no data, then the aligned value for such a period is created by
        /// interpolation. The `value_type`  of the aligned result is the same as
        /// the `value_type` of the input.
        AlignDelta,
        /// Align and convert to a rate. The result is computed as
        /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
        /// Think of this aligner as providing the slope of the line that passes
        /// through the value at the start and at the end of the `alignment_period`.
        ///
        /// This aligner is valid for `CUMULATIVE`
        /// and `DELTA` metrics with numeric values. If the selected alignment
        /// period results in periods with no data, then the aligned value for
        /// such a period is created by interpolation. The output is a `GAUGE`
        /// metric with `value_type` `DOUBLE`.
        ///
        /// If, by "rate", you mean "percentage change", see the
        /// `ALIGN_PERCENT_CHANGE` aligner instead.
        AlignRate,
        /// Align by interpolating between adjacent points around the alignment
        /// period boundary. This aligner is valid for `GAUGE` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as the
        /// `value_type` of the input.
        AlignInterpolate,
        /// Align by moving the most recent data point before the end of the
        /// alignment period to the boundary at the end of the alignment
        /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
        /// the aligned result is the same as the `value_type` of the input.
        AlignNextOlder,
        /// Align the time series by returning the minimum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMin,
        /// Align the time series by returning the maximum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMax,
        /// Align the time series by returning the mean value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
        AlignMean,
        /// Align the time series by returning the number of values in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric or Boolean values. The `value_type` of the aligned result is
        /// `INT64`.
        AlignCount,
        /// Align the time series by returning the sum of the values in each
        /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with numeric and distribution values. The `value_type` of the
        /// aligned result is the same as the `value_type` of the input.
        AlignSum,
        /// Align the time series by returning the standard deviation of the values
        /// in each alignment period. This aligner is valid for `GAUGE` and
        /// `DELTA` metrics with numeric values. The `value_type` of the output is
        /// `DOUBLE`.
        AlignStddev,
        /// Align the time series by returning the number of `True` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountTrue,
        /// Align the time series by returning the number of `False` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountFalse,
        /// Align the time series by returning the ratio of the number of `True`
        /// values to the total number of values in each alignment period. This
        /// aligner is valid for `GAUGE` metrics with Boolean values. The output
        /// value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
        AlignFractionTrue,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 99th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile99,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 95th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile95,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 50th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile50,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 5th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile05,
        /// Align and convert to a percentage change. This aligner is valid for
        /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
        /// `((current - previous)/previous) * 100`, where the value of `previous` is
        /// determined based on the `alignment_period`.
        ///
        /// If the values of `current` and `previous` are both 0, then the returned
        /// value is 0. If only `previous` is 0, the returned value is infinity.
        ///
        /// A 10-minute moving mean is computed at each point of the alignment period
        /// prior to the above calculation to smooth the metric and prevent false
        /// positives from very short-lived spikes. The moving mean is only
        /// applicable for data whose values are `>= 0`. Any values `< 0` are
        /// treated as a missing datapoint, and are ignored. While `DELTA`
        /// metrics are accepted by this alignment, special care should be taken that
        /// the values for the metric will always be positive. The output is a
        /// `GAUGE` metric with `value_type` `DOUBLE`.
        AlignPercentChange,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Aligner::value] or
        /// [Aligner::name].
        UnknownValue(aligner::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aligner {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Aligner {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AlignNone => std::option::Option::Some(0),
                Self::AlignDelta => std::option::Option::Some(1),
                Self::AlignRate => std::option::Option::Some(2),
                Self::AlignInterpolate => std::option::Option::Some(3),
                Self::AlignNextOlder => std::option::Option::Some(4),
                Self::AlignMin => std::option::Option::Some(10),
                Self::AlignMax => std::option::Option::Some(11),
                Self::AlignMean => std::option::Option::Some(12),
                Self::AlignCount => std::option::Option::Some(13),
                Self::AlignSum => std::option::Option::Some(14),
                Self::AlignStddev => std::option::Option::Some(15),
                Self::AlignCountTrue => std::option::Option::Some(16),
                Self::AlignCountFalse => std::option::Option::Some(24),
                Self::AlignFractionTrue => std::option::Option::Some(17),
                Self::AlignPercentile99 => std::option::Option::Some(18),
                Self::AlignPercentile95 => std::option::Option::Some(19),
                Self::AlignPercentile50 => std::option::Option::Some(20),
                Self::AlignPercentile05 => std::option::Option::Some(21),
                Self::AlignPercentChange => std::option::Option::Some(23),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AlignNone => std::option::Option::Some("ALIGN_NONE"),
                Self::AlignDelta => std::option::Option::Some("ALIGN_DELTA"),
                Self::AlignRate => std::option::Option::Some("ALIGN_RATE"),
                Self::AlignInterpolate => std::option::Option::Some("ALIGN_INTERPOLATE"),
                Self::AlignNextOlder => std::option::Option::Some("ALIGN_NEXT_OLDER"),
                Self::AlignMin => std::option::Option::Some("ALIGN_MIN"),
                Self::AlignMax => std::option::Option::Some("ALIGN_MAX"),
                Self::AlignMean => std::option::Option::Some("ALIGN_MEAN"),
                Self::AlignCount => std::option::Option::Some("ALIGN_COUNT"),
                Self::AlignSum => std::option::Option::Some("ALIGN_SUM"),
                Self::AlignStddev => std::option::Option::Some("ALIGN_STDDEV"),
                Self::AlignCountTrue => std::option::Option::Some("ALIGN_COUNT_TRUE"),
                Self::AlignCountFalse => std::option::Option::Some("ALIGN_COUNT_FALSE"),
                Self::AlignFractionTrue => std::option::Option::Some("ALIGN_FRACTION_TRUE"),
                Self::AlignPercentile99 => std::option::Option::Some("ALIGN_PERCENTILE_99"),
                Self::AlignPercentile95 => std::option::Option::Some("ALIGN_PERCENTILE_95"),
                Self::AlignPercentile50 => std::option::Option::Some("ALIGN_PERCENTILE_50"),
                Self::AlignPercentile05 => std::option::Option::Some("ALIGN_PERCENTILE_05"),
                Self::AlignPercentChange => std::option::Option::Some("ALIGN_PERCENT_CHANGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Aligner {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Aligner {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Aligner {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AlignNone,
                1 => Self::AlignDelta,
                2 => Self::AlignRate,
                3 => Self::AlignInterpolate,
                4 => Self::AlignNextOlder,
                10 => Self::AlignMin,
                11 => Self::AlignMax,
                12 => Self::AlignMean,
                13 => Self::AlignCount,
                14 => Self::AlignSum,
                15 => Self::AlignStddev,
                16 => Self::AlignCountTrue,
                17 => Self::AlignFractionTrue,
                18 => Self::AlignPercentile99,
                19 => Self::AlignPercentile95,
                20 => Self::AlignPercentile50,
                21 => Self::AlignPercentile05,
                23 => Self::AlignPercentChange,
                24 => Self::AlignCountFalse,
                _ => Self::UnknownValue(aligner::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Aligner {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALIGN_NONE" => Self::AlignNone,
                "ALIGN_DELTA" => Self::AlignDelta,
                "ALIGN_RATE" => Self::AlignRate,
                "ALIGN_INTERPOLATE" => Self::AlignInterpolate,
                "ALIGN_NEXT_OLDER" => Self::AlignNextOlder,
                "ALIGN_MIN" => Self::AlignMin,
                "ALIGN_MAX" => Self::AlignMax,
                "ALIGN_MEAN" => Self::AlignMean,
                "ALIGN_COUNT" => Self::AlignCount,
                "ALIGN_SUM" => Self::AlignSum,
                "ALIGN_STDDEV" => Self::AlignStddev,
                "ALIGN_COUNT_TRUE" => Self::AlignCountTrue,
                "ALIGN_COUNT_FALSE" => Self::AlignCountFalse,
                "ALIGN_FRACTION_TRUE" => Self::AlignFractionTrue,
                "ALIGN_PERCENTILE_99" => Self::AlignPercentile99,
                "ALIGN_PERCENTILE_95" => Self::AlignPercentile95,
                "ALIGN_PERCENTILE_50" => Self::AlignPercentile50,
                "ALIGN_PERCENTILE_05" => Self::AlignPercentile05,
                "ALIGN_PERCENT_CHANGE" => Self::AlignPercentChange,
                _ => Self::UnknownValue(aligner::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Aligner {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AlignNone => serializer.serialize_i32(0),
                Self::AlignDelta => serializer.serialize_i32(1),
                Self::AlignRate => serializer.serialize_i32(2),
                Self::AlignInterpolate => serializer.serialize_i32(3),
                Self::AlignNextOlder => serializer.serialize_i32(4),
                Self::AlignMin => serializer.serialize_i32(10),
                Self::AlignMax => serializer.serialize_i32(11),
                Self::AlignMean => serializer.serialize_i32(12),
                Self::AlignCount => serializer.serialize_i32(13),
                Self::AlignSum => serializer.serialize_i32(14),
                Self::AlignStddev => serializer.serialize_i32(15),
                Self::AlignCountTrue => serializer.serialize_i32(16),
                Self::AlignCountFalse => serializer.serialize_i32(24),
                Self::AlignFractionTrue => serializer.serialize_i32(17),
                Self::AlignPercentile99 => serializer.serialize_i32(18),
                Self::AlignPercentile95 => serializer.serialize_i32(19),
                Self::AlignPercentile50 => serializer.serialize_i32(20),
                Self::AlignPercentile05 => serializer.serialize_i32(21),
                Self::AlignPercentChange => serializer.serialize_i32(23),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Aligner {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Aligner>::new(
                ".google.monitoring.dashboard.v1.Aggregation.Aligner",
            ))
        }
    }

    /// A Reducer operation describes how to aggregate data points from multiple
    /// time series into a single time series, where the value of each data point
    /// in the resulting series is a function of all the already aligned values in
    /// the input time series.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reducer {
        /// No cross-time series reduction. The output of the `Aligner` is
        /// returned.
        ReduceNone,
        /// Reduce by computing the mean value across time series for each
        /// alignment period. This reducer is valid for
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
        /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
        /// numeric or distribution values. The `value_type` of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        ReduceMean,
        /// Reduce by computing the minimum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMin,
        /// Reduce by computing the maximum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMax,
        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric and distribution values. The `value_type` of the output is
        /// the same as the `value_type` of the input.
        ReduceSum,
        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics with numeric or distribution values. The `value_type`
        /// of the output is `DOUBLE`.
        ReduceStddev,
        /// Reduce by computing the number of data points across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of numeric, Boolean, distribution, and string
        /// `value_type`. The `value_type` of the output is `INT64`.
        ReduceCount,
        /// Reduce by computing the number of `True`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountTrue,
        /// Reduce by computing the number of `False`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountFalse,
        /// Reduce by computing the ratio of the number of `True`-valued data points
        /// to the total number of data points for each alignment period. This
        /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
        /// The output value is in the range [0.0, 1.0] and has `value_type`
        /// `DOUBLE`.
        ReduceFractionTrue,
        /// Reduce by computing the [99th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile99,
        /// Reduce by computing the [95th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile95,
        /// Reduce by computing the [50th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile50,
        /// Reduce by computing the [5th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile05,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Reducer::value] or
        /// [Reducer::name].
        UnknownValue(reducer::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reducer {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Reducer {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ReduceNone => std::option::Option::Some(0),
                Self::ReduceMean => std::option::Option::Some(1),
                Self::ReduceMin => std::option::Option::Some(2),
                Self::ReduceMax => std::option::Option::Some(3),
                Self::ReduceSum => std::option::Option::Some(4),
                Self::ReduceStddev => std::option::Option::Some(5),
                Self::ReduceCount => std::option::Option::Some(6),
                Self::ReduceCountTrue => std::option::Option::Some(7),
                Self::ReduceCountFalse => std::option::Option::Some(15),
                Self::ReduceFractionTrue => std::option::Option::Some(8),
                Self::ReducePercentile99 => std::option::Option::Some(9),
                Self::ReducePercentile95 => std::option::Option::Some(10),
                Self::ReducePercentile50 => std::option::Option::Some(11),
                Self::ReducePercentile05 => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ReduceNone => std::option::Option::Some("REDUCE_NONE"),
                Self::ReduceMean => std::option::Option::Some("REDUCE_MEAN"),
                Self::ReduceMin => std::option::Option::Some("REDUCE_MIN"),
                Self::ReduceMax => std::option::Option::Some("REDUCE_MAX"),
                Self::ReduceSum => std::option::Option::Some("REDUCE_SUM"),
                Self::ReduceStddev => std::option::Option::Some("REDUCE_STDDEV"),
                Self::ReduceCount => std::option::Option::Some("REDUCE_COUNT"),
                Self::ReduceCountTrue => std::option::Option::Some("REDUCE_COUNT_TRUE"),
                Self::ReduceCountFalse => std::option::Option::Some("REDUCE_COUNT_FALSE"),
                Self::ReduceFractionTrue => std::option::Option::Some("REDUCE_FRACTION_TRUE"),
                Self::ReducePercentile99 => std::option::Option::Some("REDUCE_PERCENTILE_99"),
                Self::ReducePercentile95 => std::option::Option::Some("REDUCE_PERCENTILE_95"),
                Self::ReducePercentile50 => std::option::Option::Some("REDUCE_PERCENTILE_50"),
                Self::ReducePercentile05 => std::option::Option::Some("REDUCE_PERCENTILE_05"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Reducer {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Reducer {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Reducer {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ReduceNone,
                1 => Self::ReduceMean,
                2 => Self::ReduceMin,
                3 => Self::ReduceMax,
                4 => Self::ReduceSum,
                5 => Self::ReduceStddev,
                6 => Self::ReduceCount,
                7 => Self::ReduceCountTrue,
                8 => Self::ReduceFractionTrue,
                9 => Self::ReducePercentile99,
                10 => Self::ReducePercentile95,
                11 => Self::ReducePercentile50,
                12 => Self::ReducePercentile05,
                15 => Self::ReduceCountFalse,
                _ => Self::UnknownValue(reducer::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Reducer {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDUCE_NONE" => Self::ReduceNone,
                "REDUCE_MEAN" => Self::ReduceMean,
                "REDUCE_MIN" => Self::ReduceMin,
                "REDUCE_MAX" => Self::ReduceMax,
                "REDUCE_SUM" => Self::ReduceSum,
                "REDUCE_STDDEV" => Self::ReduceStddev,
                "REDUCE_COUNT" => Self::ReduceCount,
                "REDUCE_COUNT_TRUE" => Self::ReduceCountTrue,
                "REDUCE_COUNT_FALSE" => Self::ReduceCountFalse,
                "REDUCE_FRACTION_TRUE" => Self::ReduceFractionTrue,
                "REDUCE_PERCENTILE_99" => Self::ReducePercentile99,
                "REDUCE_PERCENTILE_95" => Self::ReducePercentile95,
                "REDUCE_PERCENTILE_50" => Self::ReducePercentile50,
                "REDUCE_PERCENTILE_05" => Self::ReducePercentile05,
                _ => Self::UnknownValue(reducer::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Reducer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ReduceNone => serializer.serialize_i32(0),
                Self::ReduceMean => serializer.serialize_i32(1),
                Self::ReduceMin => serializer.serialize_i32(2),
                Self::ReduceMax => serializer.serialize_i32(3),
                Self::ReduceSum => serializer.serialize_i32(4),
                Self::ReduceStddev => serializer.serialize_i32(5),
                Self::ReduceCount => serializer.serialize_i32(6),
                Self::ReduceCountTrue => serializer.serialize_i32(7),
                Self::ReduceCountFalse => serializer.serialize_i32(15),
                Self::ReduceFractionTrue => serializer.serialize_i32(8),
                Self::ReducePercentile99 => serializer.serialize_i32(9),
                Self::ReducePercentile95 => serializer.serialize_i32(10),
                Self::ReducePercentile50 => serializer.serialize_i32(11),
                Self::ReducePercentile05 => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Reducer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reducer>::new(
                ".google.monitoring.dashboard.v1.Aggregation.Reducer",
            ))
        }
    }
}

/// Describes a ranking-based time series filter. Each input time series is
/// ranked with an aligner. The filter will allow up to `num_time_series` time
/// series to pass through it, selecting them based on the relative ranking.
///
/// For example, if `ranking_method` is `METHOD_MEAN`,`direction` is `BOTTOM`,
/// and `num_time_series` is 3, then the 3 times series with the lowest mean
/// values will pass through the filter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PickTimeSeriesFilter {
    /// `ranking_method` is applied to each time series independently to produce
    /// the value which will be used to compare the time series to other time
    /// series.
    pub ranking_method: crate::model::pick_time_series_filter::Method,

    /// How many time series to allow to pass through the filter.
    pub num_time_series: i32,

    /// How to use the ranking to select time series that pass through the filter.
    pub direction: crate::model::pick_time_series_filter::Direction,

    /// Select the top N streams/time series within this time interval
    pub interval: std::option::Option<gtype::model::Interval>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PickTimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ranking_method][crate::model::PickTimeSeriesFilter::ranking_method].
    pub fn set_ranking_method<
        T: std::convert::Into<crate::model::pick_time_series_filter::Method>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_method = v.into();
        self
    }

    /// Sets the value of [num_time_series][crate::model::PickTimeSeriesFilter::num_time_series].
    pub fn set_num_time_series<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_time_series = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::PickTimeSeriesFilter::direction].
    pub fn set_direction<
        T: std::convert::Into<crate::model::pick_time_series_filter::Direction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::PickTimeSeriesFilter::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::PickTimeSeriesFilter::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PickTimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.PickTimeSeriesFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PickTimeSeriesFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ranking_method,
            __num_time_series,
            __direction,
            __interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PickTimeSeriesFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rankingMethod" => Ok(__FieldTag::__ranking_method),
                            "ranking_method" => Ok(__FieldTag::__ranking_method),
                            "numTimeSeries" => Ok(__FieldTag::__num_time_series),
                            "num_time_series" => Ok(__FieldTag::__num_time_series),
                            "direction" => Ok(__FieldTag::__direction),
                            "interval" => Ok(__FieldTag::__interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PickTimeSeriesFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PickTimeSeriesFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ranking_method => {
                            if !fields.insert(__FieldTag::__ranking_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ranking_method",
                                ));
                            }
                            result.ranking_method =
                                map.next_value::<std::option::Option<
                                    crate::model::pick_time_series_filter::Method,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_time_series => {
                            if !fields.insert(__FieldTag::__num_time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_time_series",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_time_series =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map
                                .next_value::<std::option::Option<
                                    crate::model::pick_time_series_filter::Direction,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval =
                                map.next_value::<std::option::Option<gtype::model::Interval>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PickTimeSeriesFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ranking_method) {
            state.serialize_entry("rankingMethod", &self.ranking_method)?;
        }
        if !wkt::internal::is_default(&self.num_time_series) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numTimeSeries", &__With(&self.num_time_series))?;
        }
        if !wkt::internal::is_default(&self.direction) {
            state.serialize_entry("direction", &self.direction)?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PickTimeSeriesFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PickTimeSeriesFilter");
        debug_struct.field("ranking_method", &self.ranking_method);
        debug_struct.field("num_time_series", &self.num_time_series);
        debug_struct.field("direction", &self.direction);
        debug_struct.field("interval", &self.interval);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PickTimeSeriesFilter].
pub mod pick_time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The value reducers that can be applied to a `PickTimeSeriesFilter`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Not allowed. You must specify a different `Method` if you specify a
        /// `PickTimeSeriesFilter`.
        Unspecified,
        /// Select the mean of all values.
        Mean,
        /// Select the maximum value.
        Max,
        /// Select the minimum value.
        Min,
        /// Compute the sum of all values.
        Sum,
        /// Select the most recent value.
        Latest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Method::value] or
        /// [Method::name].
        UnknownValue(method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Method {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Mean => std::option::Option::Some(1),
                Self::Max => std::option::Option::Some(2),
                Self::Min => std::option::Option::Some(3),
                Self::Sum => std::option::Option::Some(4),
                Self::Latest => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                Self::Mean => std::option::Option::Some("METHOD_MEAN"),
                Self::Max => std::option::Option::Some("METHOD_MAX"),
                Self::Min => std::option::Option::Some("METHOD_MIN"),
                Self::Sum => std::option::Option::Some("METHOD_SUM"),
                Self::Latest => std::option::Option::Some("METHOD_LATEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Method {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Mean,
                2 => Self::Max,
                3 => Self::Min,
                4 => Self::Sum,
                5 => Self::Latest,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Method {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_UNSPECIFIED" => Self::Unspecified,
                "METHOD_MEAN" => Self::Mean,
                "METHOD_MAX" => Self::Max,
                "METHOD_MIN" => Self::Min,
                "METHOD_SUM" => Self::Sum,
                "METHOD_LATEST" => Self::Latest,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Method {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Mean => serializer.serialize_i32(1),
                Self::Max => serializer.serialize_i32(2),
                Self::Min => serializer.serialize_i32(3),
                Self::Sum => serializer.serialize_i32(4),
                Self::Latest => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Method {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                ".google.monitoring.dashboard.v1.PickTimeSeriesFilter.Method",
            ))
        }
    }

    /// Describes the ranking directions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Not allowed. You must specify a different `Direction` if you specify a
        /// `PickTimeSeriesFilter`.
        Unspecified,
        /// Pass the highest `num_time_series` ranking inputs.
        Top,
        /// Pass the lowest `num_time_series` ranking inputs.
        Bottom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Top => std::option::Option::Some(1),
                Self::Bottom => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Top => std::option::Option::Some("TOP"),
                Self::Bottom => std::option::Option::Some("BOTTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Top,
                2 => Self::Bottom,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "TOP" => Self::Top,
                "BOTTOM" => Self::Bottom,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Top => serializer.serialize_i32(1),
                Self::Bottom => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.monitoring.dashboard.v1.PickTimeSeriesFilter.Direction",
            ))
        }
    }
}

/// A filter that ranks streams based on their statistical relation to other
/// streams in a request.
/// Note: This field is deprecated and completely ignored by the API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StatisticalTimeSeriesFilter {
    /// `rankingMethod` is applied to a set of time series, and then the produced
    /// value for each individual time series is used to compare a given time
    /// series to others.
    /// These are methods that cannot be applied stream-by-stream, but rather
    /// require the full context of a request to evaluate time series.
    pub ranking_method: crate::model::statistical_time_series_filter::Method,

    /// How many time series to output.
    pub num_time_series: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatisticalTimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ranking_method][crate::model::StatisticalTimeSeriesFilter::ranking_method].
    pub fn set_ranking_method<
        T: std::convert::Into<crate::model::statistical_time_series_filter::Method>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_method = v.into();
        self
    }

    /// Sets the value of [num_time_series][crate::model::StatisticalTimeSeriesFilter::num_time_series].
    pub fn set_num_time_series<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_time_series = v.into();
        self
    }
}

impl wkt::message::Message for StatisticalTimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StatisticalTimeSeriesFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ranking_method,
            __num_time_series,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatisticalTimeSeriesFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rankingMethod" => Ok(__FieldTag::__ranking_method),
                            "ranking_method" => Ok(__FieldTag::__ranking_method),
                            "numTimeSeries" => Ok(__FieldTag::__num_time_series),
                            "num_time_series" => Ok(__FieldTag::__num_time_series),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StatisticalTimeSeriesFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatisticalTimeSeriesFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ranking_method => {
                            if !fields.insert(__FieldTag::__ranking_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ranking_method",
                                ));
                            }
                            result.ranking_method = map
                                .next_value::<std::option::Option<
                                    crate::model::statistical_time_series_filter::Method,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_time_series => {
                            if !fields.insert(__FieldTag::__num_time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_time_series",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_time_series =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StatisticalTimeSeriesFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ranking_method) {
            state.serialize_entry("rankingMethod", &self.ranking_method)?;
        }
        if !wkt::internal::is_default(&self.num_time_series) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numTimeSeries", &__With(&self.num_time_series))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StatisticalTimeSeriesFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StatisticalTimeSeriesFilter");
        debug_struct.field("ranking_method", &self.ranking_method);
        debug_struct.field("num_time_series", &self.num_time_series);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [StatisticalTimeSeriesFilter].
pub mod statistical_time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The filter methods that can be applied to a stream.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Not allowed in well-formed requests.
        Unspecified,
        /// Compute the outlier score of each stream.
        ClusterOutlier,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Method::value] or
        /// [Method::name].
        UnknownValue(method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Method {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ClusterOutlier => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                Self::ClusterOutlier => std::option::Option::Some("METHOD_CLUSTER_OUTLIER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Method {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ClusterOutlier,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Method {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_UNSPECIFIED" => Self::Unspecified,
                "METHOD_CLUSTER_OUTLIER" => Self::ClusterOutlier,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Method {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ClusterOutlier => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Method {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                ".google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter.Method",
            ))
        }
    }
}

/// A Google Stackdriver dashboard. Dashboards define the content and layout
/// of pages in the Stackdriver web application.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Dashboard {
    /// Identifier. The resource name of the dashboard.
    pub name: std::string::String,

    /// Required. The mutable, human-readable name.
    pub display_name: std::string::String,

    /// `etag` is used for optimistic concurrency control as a way to help
    /// prevent simultaneous updates of a policy from overwriting each other.
    /// An `etag` is returned in the response to `GetDashboard`, and
    /// users are expected to put that etag in the request to `UpdateDashboard` to
    /// ensure that their change will be applied to the same version of the
    /// Dashboard configuration. The field should not be passed during
    /// dashboard creation.
    pub etag: std::string::String,

    /// Filters to reduce the amount of data charted based on the filter criteria.
    pub dashboard_filters: std::vec::Vec<crate::model::DashboardFilter>,

    /// Labels applied to the dashboard
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A dashboard's root container element that defines the layout style.
    pub layout: std::option::Option<crate::model::dashboard::Layout>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dashboard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dashboard::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Dashboard::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Dashboard::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [dashboard_filters][crate::model::Dashboard::dashboard_filters].
    pub fn set_dashboard_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DashboardFilter>,
    {
        use std::iter::Iterator;
        self.dashboard_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Dashboard::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout].
    ///
    /// Note that all the setters affecting `layout` are mutually
    /// exclusive.
    pub fn set_layout<
        T: std::convert::Into<std::option::Option<crate::model::dashboard::Layout>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.layout = v.into();
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `GridLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn grid_layout(&self) -> std::option::Option<&std::boxed::Box<crate::model::GridLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::GridLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `GridLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_grid_layout<T: std::convert::Into<std::boxed::Box<crate::model::GridLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::GridLayout(v.into()));
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `MosaicLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mosaic_layout(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MosaicLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::MosaicLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `MosaicLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_mosaic_layout<T: std::convert::Into<std::boxed::Box<crate::model::MosaicLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::MosaicLayout(v.into()));
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `RowLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn row_layout(&self) -> std::option::Option<&std::boxed::Box<crate::model::RowLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::RowLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `RowLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_row_layout<T: std::convert::Into<std::boxed::Box<crate::model::RowLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::RowLayout(v.into()));
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `ColumnLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn column_layout(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ColumnLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::ColumnLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `ColumnLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_column_layout<T: std::convert::Into<std::boxed::Box<crate::model::ColumnLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::ColumnLayout(v.into()));
        self
    }
}

impl wkt::message::Message for Dashboard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Dashboard"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Dashboard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __etag,
            __grid_layout,
            __mosaic_layout,
            __row_layout,
            __column_layout,
            __dashboard_filters,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dashboard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "etag" => Ok(__FieldTag::__etag),
                            "gridLayout" => Ok(__FieldTag::__grid_layout),
                            "grid_layout" => Ok(__FieldTag::__grid_layout),
                            "mosaicLayout" => Ok(__FieldTag::__mosaic_layout),
                            "mosaic_layout" => Ok(__FieldTag::__mosaic_layout),
                            "rowLayout" => Ok(__FieldTag::__row_layout),
                            "row_layout" => Ok(__FieldTag::__row_layout),
                            "columnLayout" => Ok(__FieldTag::__column_layout),
                            "column_layout" => Ok(__FieldTag::__column_layout),
                            "dashboardFilters" => Ok(__FieldTag::__dashboard_filters),
                            "dashboard_filters" => Ok(__FieldTag::__dashboard_filters),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Dashboard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dashboard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grid_layout => {
                            if !fields.insert(__FieldTag::__grid_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grid_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.grid_layout, latest field was gridLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::GridLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GridLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mosaic_layout => {
                            if !fields.insert(__FieldTag::__mosaic_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mosaic_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.mosaic_layout, latest field was mosaicLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::MosaicLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MosaicLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__row_layout => {
                            if !fields.insert(__FieldTag::__row_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.row_layout, latest field was rowLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::RowLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RowLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__column_layout => {
                            if !fields.insert(__FieldTag::__column_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.column_layout, latest field was columnLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::ColumnLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ColumnLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dashboard_filters => {
                            if !fields.insert(__FieldTag::__dashboard_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboard_filters",
                                ));
                            }
                            result.dashboard_filters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DashboardFilter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Dashboard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if let Some(value) = self.grid_layout() {
            state.serialize_entry("gridLayout", value)?;
        }
        if let Some(value) = self.mosaic_layout() {
            state.serialize_entry("mosaicLayout", value)?;
        }
        if let Some(value) = self.row_layout() {
            state.serialize_entry("rowLayout", value)?;
        }
        if let Some(value) = self.column_layout() {
            state.serialize_entry("columnLayout", value)?;
        }
        if !self.dashboard_filters.is_empty() {
            state.serialize_entry("dashboardFilters", &self.dashboard_filters)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Dashboard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Dashboard");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("dashboard_filters", &self.dashboard_filters);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("layout", &self.layout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Dashboard].
pub mod dashboard {
    #[allow(unused_imports)]
    use super::*;

    /// A dashboard's root container element that defines the layout style.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Layout {
        /// Content is arranged with a basic layout that re-flows a simple list of
        /// informational elements like widgets or tiles.
        GridLayout(std::boxed::Box<crate::model::GridLayout>),
        /// The content is arranged as a grid of tiles, with each content widget
        /// occupying one or more grid blocks.
        MosaicLayout(std::boxed::Box<crate::model::MosaicLayout>),
        /// The content is divided into equally spaced rows and the widgets are
        /// arranged horizontally.
        RowLayout(std::boxed::Box<crate::model::RowLayout>),
        /// The content is divided into equally spaced columns and the widgets are
        /// arranged vertically.
        ColumnLayout(std::boxed::Box<crate::model::ColumnLayout>),
    }
}

/// A filter to reduce the amount of data charted in relevant widgets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DashboardFilter {
    /// Required. The key for the label
    pub label_key: std::string::String,

    /// The placeholder text that can be referenced in a filter string or MQL
    /// query. If omitted, the dashboard filter will be applied to all relevant
    /// widgets in the dashboard.
    pub template_variable: std::string::String,

    /// The specified filter type
    pub filter_type: crate::model::dashboard_filter::FilterType,

    /// The default value used in the filter comparison
    pub default_value: std::option::Option<crate::model::dashboard_filter::DefaultValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DashboardFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_key][crate::model::DashboardFilter::label_key].
    pub fn set_label_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label_key = v.into();
        self
    }

    /// Sets the value of [template_variable][crate::model::DashboardFilter::template_variable].
    pub fn set_template_variable<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.template_variable = v.into();
        self
    }

    /// Sets the value of [filter_type][crate::model::DashboardFilter::filter_type].
    pub fn set_filter_type<T: std::convert::Into<crate::model::dashboard_filter::FilterType>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_type = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::DashboardFilter::default_value].
    ///
    /// Note that all the setters affecting `default_value` are mutually
    /// exclusive.
    pub fn set_default_value<
        T: std::convert::Into<std::option::Option<crate::model::dashboard_filter::DefaultValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_value = v.into();
        self
    }

    /// The value of [default_value][crate::model::DashboardFilter::default_value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.default_value.as_ref().and_then(|v| match v {
            crate::model::dashboard_filter::DefaultValue::StringValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [default_value][crate::model::DashboardFilter::default_value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `default_value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = std::option::Option::Some(
            crate::model::dashboard_filter::DefaultValue::StringValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DashboardFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.DashboardFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DashboardFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label_key,
            __template_variable,
            __string_value,
            __filter_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DashboardFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labelKey" => Ok(__FieldTag::__label_key),
                            "label_key" => Ok(__FieldTag::__label_key),
                            "templateVariable" => Ok(__FieldTag::__template_variable),
                            "template_variable" => Ok(__FieldTag::__template_variable),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "filterType" => Ok(__FieldTag::__filter_type),
                            "filter_type" => Ok(__FieldTag::__filter_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DashboardFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DashboardFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label_key => {
                            if !fields.insert(__FieldTag::__label_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_key",
                                ));
                            }
                            result.label_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template_variable => {
                            if !fields.insert(__FieldTag::__template_variable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_variable",
                                ));
                            }
                            result.template_variable = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.default_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `default_value`, a oneof with full ID .google.monitoring.dashboard.v1.DashboardFilter.string_value, latest field was stringValue",
                                ));
                            }
                            result.default_value = std::option::Option::Some(
                                crate::model::dashboard_filter::DefaultValue::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__filter_type => {
                            if !fields.insert(__FieldTag::__filter_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_type",
                                ));
                            }
                            result.filter_type = map.next_value::<std::option::Option<crate::model::dashboard_filter::FilterType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DashboardFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.label_key.is_empty() {
            state.serialize_entry("labelKey", &self.label_key)?;
        }
        if !self.template_variable.is_empty() {
            state.serialize_entry("templateVariable", &self.template_variable)?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if !wkt::internal::is_default(&self.filter_type) {
            state.serialize_entry("filterType", &self.filter_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DashboardFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DashboardFilter");
        debug_struct.field("label_key", &self.label_key);
        debug_struct.field("template_variable", &self.template_variable);
        debug_struct.field("filter_type", &self.filter_type);
        debug_struct.field("default_value", &self.default_value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DashboardFilter].
pub mod dashboard_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The type for the dashboard filter
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FilterType {
        /// Filter type is unspecified. This is not valid in a well-formed request.
        Unspecified,
        /// Filter on a resource label value
        ResourceLabel,
        /// Filter on a metrics label value
        MetricLabel,
        /// Filter on a user metadata label value
        UserMetadataLabel,
        /// Filter on a system metadata label value
        SystemMetadataLabel,
        /// Filter on a group id
        Group,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FilterType::value] or
        /// [FilterType::name].
        UnknownValue(filter_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod filter_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FilterType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceLabel => std::option::Option::Some(1),
                Self::MetricLabel => std::option::Option::Some(2),
                Self::UserMetadataLabel => std::option::Option::Some(3),
                Self::SystemMetadataLabel => std::option::Option::Some(4),
                Self::Group => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FILTER_TYPE_UNSPECIFIED"),
                Self::ResourceLabel => std::option::Option::Some("RESOURCE_LABEL"),
                Self::MetricLabel => std::option::Option::Some("METRIC_LABEL"),
                Self::UserMetadataLabel => std::option::Option::Some("USER_METADATA_LABEL"),
                Self::SystemMetadataLabel => std::option::Option::Some("SYSTEM_METADATA_LABEL"),
                Self::Group => std::option::Option::Some("GROUP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FilterType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FilterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FilterType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResourceLabel,
                2 => Self::MetricLabel,
                3 => Self::UserMetadataLabel,
                4 => Self::SystemMetadataLabel,
                5 => Self::Group,
                _ => Self::UnknownValue(filter_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FilterType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FILTER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_LABEL" => Self::ResourceLabel,
                "METRIC_LABEL" => Self::MetricLabel,
                "USER_METADATA_LABEL" => Self::UserMetadataLabel,
                "SYSTEM_METADATA_LABEL" => Self::SystemMetadataLabel,
                "GROUP" => Self::Group,
                _ => Self::UnknownValue(filter_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FilterType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceLabel => serializer.serialize_i32(1),
                Self::MetricLabel => serializer.serialize_i32(2),
                Self::UserMetadataLabel => serializer.serialize_i32(3),
                Self::SystemMetadataLabel => serializer.serialize_i32(4),
                Self::Group => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FilterType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilterType>::new(
                ".google.monitoring.dashboard.v1.DashboardFilter.FilterType",
            ))
        }
    }

    /// The default value used in the filter comparison
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DefaultValue {
        /// A variable-length string value.
        StringValue(std::string::String),
    }
}

/// The `CreateDashboard` request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDashboardRequest {
    /// Required. The project on which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// The `[PROJECT_ID_OR_NUMBER]` must match the dashboard resource name.
    pub parent: std::string::String,

    /// Required. The initial dashboard specification.
    pub dashboard: std::option::Option<crate::model::Dashboard>,

    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDashboardRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dashboard][crate::model::CreateDashboardRequest::dashboard].
    pub fn set_dashboard<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dashboard>,
    {
        self.dashboard = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dashboard][crate::model::CreateDashboardRequest::dashboard].
    pub fn set_or_clear_dashboard<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dashboard>,
    {
        self.dashboard = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDashboardRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.CreateDashboardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dashboard,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dashboard" => Ok(__FieldTag::__dashboard),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dashboard => {
                            if !fields.insert(__FieldTag::__dashboard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboard",
                                ));
                            }
                            result.dashboard =
                                map.next_value::<std::option::Option<crate::model::Dashboard>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDashboardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.dashboard.is_some() {
            state.serialize_entry("dashboard", &self.dashboard)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDashboardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDashboardRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("dashboard", &self.dashboard);
        debug_struct.field("validate_only", &self.validate_only);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `ListDashboards` request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDashboardsRequest {
    /// Required. The scope of the dashboards to list. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub parent: std::string::String,

    /// A positive number that is the maximum number of results to return.
    /// If unspecified, a default of 1000 is used.
    pub page_size: i32,

    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return additional results from the previous
    /// method call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDashboardsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDashboardsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDashboardsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDashboardsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDashboardsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ListDashboardsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDashboardsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDashboardsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDashboardsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDashboardsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDashboardsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDashboardsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDashboardsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `ListDashboards` request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDashboardsResponse {
    /// The list of requested dashboards.
    pub dashboards: std::vec::Vec<crate::model::Dashboard>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDashboardsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dashboards][crate::model::ListDashboardsResponse::dashboards].
    pub fn set_dashboards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dashboard>,
    {
        use std::iter::Iterator;
        self.dashboards = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDashboardsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDashboardsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ListDashboardsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDashboardsResponse {
    type PageItem = crate::model::Dashboard;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dashboards
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDashboardsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dashboards,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDashboardsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dashboards" => Ok(__FieldTag::__dashboards),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDashboardsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDashboardsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dashboards => {
                            if !fields.insert(__FieldTag::__dashboards) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboards",
                                ));
                            }
                            result.dashboards = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dashboard>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDashboardsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dashboards.is_empty() {
            state.serialize_entry("dashboards", &self.dashboards)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDashboardsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDashboardsResponse");
        debug_struct.field("dashboards", &self.dashboards);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `GetDashboard` request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is one of:
    ///
    /// - `dashboards/[DASHBOARD_ID]` (for system dashboards)
    /// - `projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID]`
    ///   (for custom dashboards).
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDashboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.GetDashboardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDashboardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDashboardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDashboardRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `DeleteDashboard` request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDashboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.DeleteDashboardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDashboardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDashboardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDashboardRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `UpdateDashboard` request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDashboardRequest {
    /// Required. The dashboard that will replace the existing dashboard.
    pub dashboard: std::option::Option<crate::model::Dashboard>,

    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dashboard][crate::model::UpdateDashboardRequest::dashboard].
    pub fn set_dashboard<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dashboard>,
    {
        self.dashboard = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dashboard][crate::model::UpdateDashboardRequest::dashboard].
    pub fn set_or_clear_dashboard<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dashboard>,
    {
        self.dashboard = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDashboardRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.UpdateDashboardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dashboard,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dashboard" => Ok(__FieldTag::__dashboard),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dashboard => {
                            if !fields.insert(__FieldTag::__dashboard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboard",
                                ));
                            }
                            result.dashboard =
                                map.next_value::<std::option::Option<crate::model::Dashboard>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDashboardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dashboard.is_some() {
            state.serialize_entry("dashboard", &self.dashboard)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateDashboardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDashboardRequest");
        debug_struct.field("dashboard", &self.dashboard);
        debug_struct.field("validate_only", &self.validate_only);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A widget that displays a list of error groups.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorReportingPanel {
    /// The resource name of the Google Cloud Platform project. Written
    /// as `projects/{projectID}` or `projects/{projectNumber}`, where
    /// `{projectID}` and `{projectNumber}` can be found in the
    /// [Google Cloud console](https://support.google.com/cloud/answer/6158840).
    ///
    /// Examples: `projects/my-project-123`, `projects/5551234`.
    pub project_names: std::vec::Vec<std::string::String>,

    /// An identifier of the service, such as the name of the
    /// executable, job, or Google App Engine service name. This field is expected
    /// to have a low number of values that are relatively stable over time, as
    /// opposed to `version`, which can be changed whenever new code is deployed.
    ///
    /// Contains the service name for error reports extracted from Google
    /// App Engine logs or `default` if the App Engine default service is used.
    pub services: std::vec::Vec<std::string::String>,

    /// Represents the source code version that the developer provided,
    /// which could represent a version label or a Git SHA-1 hash, for example.
    /// For App Engine standard environment, the version is set to the version of
    /// the app.
    pub versions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorReportingPanel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_names][crate::model::ErrorReportingPanel::project_names].
    pub fn set_project_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.project_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [services][crate::model::ErrorReportingPanel::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [versions][crate::model::ErrorReportingPanel::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorReportingPanel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ErrorReportingPanel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorReportingPanel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_names,
            __services,
            __versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorReportingPanel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectNames" => Ok(__FieldTag::__project_names),
                            "project_names" => Ok(__FieldTag::__project_names),
                            "services" => Ok(__FieldTag::__services),
                            "versions" => Ok(__FieldTag::__versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorReportingPanel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorReportingPanel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_names => {
                            if !fields.insert(__FieldTag::__project_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_names",
                                ));
                            }
                            result.project_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorReportingPanel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_names.is_empty() {
            state.serialize_entry("projectNames", &self.project_names)?;
        }
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ErrorReportingPanel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorReportingPanel");
        debug_struct.field("project_names", &self.project_names);
        debug_struct.field("services", &self.services);
        debug_struct.field("versions", &self.versions);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A widget that displays a list of incidents
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IncidentList {
    /// Optional. The monitored resource for which incidents are listed.
    /// The resource doesn't need to be fully specified. That is, you can specify
    /// the resource type but not the values of the resource labels.
    /// The resource type and labels are used for filtering.
    pub monitored_resources: std::vec::Vec<api::model::MonitoredResource>,

    /// Optional. A list of alert policy names to filter the incident list by.
    /// Don't include the project ID prefix in the policy name. For
    /// example, use `alertPolicies/utilization`.
    pub policy_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IncidentList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [monitored_resources][crate::model::IncidentList::monitored_resources].
    pub fn set_monitored_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResource>,
    {
        use std::iter::Iterator;
        self.monitored_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [policy_names][crate::model::IncidentList::policy_names].
    pub fn set_policy_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.policy_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IncidentList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.IncidentList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IncidentList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __monitored_resources,
            __policy_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IncidentList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "monitoredResources" => Ok(__FieldTag::__monitored_resources),
                            "monitored_resources" => Ok(__FieldTag::__monitored_resources),
                            "policyNames" => Ok(__FieldTag::__policy_names),
                            "policy_names" => Ok(__FieldTag::__policy_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IncidentList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IncidentList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__monitored_resources => {
                            if !fields.insert(__FieldTag::__monitored_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitored_resources",
                                ));
                            }
                            result.monitored_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<api::model::MonitoredResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_names => {
                            if !fields.insert(__FieldTag::__policy_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_names",
                                ));
                            }
                            result.policy_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IncidentList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.monitored_resources.is_empty() {
            state.serialize_entry("monitoredResources", &self.monitored_resources)?;
        }
        if !self.policy_names.is_empty() {
            state.serialize_entry("policyNames", &self.policy_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IncidentList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IncidentList");
        debug_struct.field("monitored_resources", &self.monitored_resources);
        debug_struct.field("policy_names", &self.policy_names);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A basic layout divides the available space into vertical columns of equal
/// width and arranges a list of widgets using a row-first strategy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GridLayout {
    /// The number of columns into which the view's width is divided. If omitted
    /// or set to zero, a system default will be used while rendering.
    pub columns: i64,

    /// The informational elements that are arranged into the columns row-first.
    pub widgets: std::vec::Vec<crate::model::Widget>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GridLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::GridLayout::columns].
    pub fn set_columns<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.columns = v.into();
        self
    }

    /// Sets the value of [widgets][crate::model::GridLayout::widgets].
    pub fn set_widgets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Widget>,
    {
        use std::iter::Iterator;
        self.widgets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GridLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.GridLayout"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GridLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            __widgets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GridLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            "widgets" => Ok(__FieldTag::__widgets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GridLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GridLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.columns = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__widgets => {
                            if !fields.insert(__FieldTag::__widgets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for widgets",
                                ));
                            }
                            result.widgets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Widget>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GridLayout {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.columns) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("columns", &__With(&self.columns))?;
        }
        if !self.widgets.is_empty() {
            state.serialize_entry("widgets", &self.widgets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GridLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GridLayout");
        debug_struct.field("columns", &self.columns);
        debug_struct.field("widgets", &self.widgets);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A mosaic layout divides the available space into a grid of blocks, and
/// overlays the grid with tiles. Unlike `GridLayout`, tiles may span multiple
/// grid blocks and can be placed at arbitrary locations in the grid.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MosaicLayout {
    /// The number of columns in the mosaic grid. The number of columns must be
    /// between 1 and 12, inclusive.
    pub columns: i32,

    /// The tiles to display.
    pub tiles: std::vec::Vec<crate::model::mosaic_layout::Tile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MosaicLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::MosaicLayout::columns].
    pub fn set_columns<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.columns = v.into();
        self
    }

    /// Sets the value of [tiles][crate::model::MosaicLayout::tiles].
    pub fn set_tiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::mosaic_layout::Tile>,
    {
        use std::iter::Iterator;
        self.tiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MosaicLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.MosaicLayout"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MosaicLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            __tiles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MosaicLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            "tiles" => Ok(__FieldTag::__tiles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MosaicLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MosaicLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.columns = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tiles => {
                            if !fields.insert(__FieldTag::__tiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tiles",
                                ));
                            }
                            result.tiles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::mosaic_layout::Tile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MosaicLayout {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.columns) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("columns", &__With(&self.columns))?;
        }
        if !self.tiles.is_empty() {
            state.serialize_entry("tiles", &self.tiles)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MosaicLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MosaicLayout");
        debug_struct.field("columns", &self.columns);
        debug_struct.field("tiles", &self.tiles);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MosaicLayout].
pub mod mosaic_layout {
    #[allow(unused_imports)]
    use super::*;

    /// A single tile in the mosaic. The placement and size of the tile are
    /// configurable.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Tile {
        /// The zero-indexed position of the tile in grid blocks relative to the
        /// left edge of the grid. Tiles must be contained within the specified
        /// number of columns. `x_pos` cannot be negative.
        pub x_pos: i32,

        /// The zero-indexed position of the tile in grid blocks relative to the
        /// top edge of the grid. `y_pos` cannot be negative.
        pub y_pos: i32,

        /// The width of the tile, measured in grid blocks. Tiles must have a
        /// minimum width of 1.
        pub width: i32,

        /// The height of the tile, measured in grid blocks. Tiles must have a
        /// minimum height of 1.
        pub height: i32,

        /// The informational widget contained in the tile. For example an `XyChart`.
        pub widget: std::option::Option<crate::model::Widget>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Tile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [x_pos][crate::model::mosaic_layout::Tile::x_pos].
        pub fn set_x_pos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.x_pos = v.into();
            self
        }

        /// Sets the value of [y_pos][crate::model::mosaic_layout::Tile::y_pos].
        pub fn set_y_pos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.y_pos = v.into();
            self
        }

        /// Sets the value of [width][crate::model::mosaic_layout::Tile::width].
        pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.width = v.into();
            self
        }

        /// Sets the value of [height][crate::model::mosaic_layout::Tile::height].
        pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.height = v.into();
            self
        }

        /// Sets the value of [widget][crate::model::mosaic_layout::Tile::widget].
        pub fn set_widget<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Widget>,
        {
            self.widget = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [widget][crate::model::mosaic_layout::Tile::widget].
        pub fn set_or_clear_widget<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Widget>,
        {
            self.widget = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Tile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.MosaicLayout.Tile"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Tile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __x_pos,
                __y_pos,
                __width,
                __height,
                __widget,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Tile")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "xPos" => Ok(__FieldTag::__x_pos),
                                "x_pos" => Ok(__FieldTag::__x_pos),
                                "yPos" => Ok(__FieldTag::__y_pos),
                                "y_pos" => Ok(__FieldTag::__y_pos),
                                "width" => Ok(__FieldTag::__width),
                                "height" => Ok(__FieldTag::__height),
                                "widget" => Ok(__FieldTag::__widget),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Tile;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Tile")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__x_pos => {
                                if !fields.insert(__FieldTag::__x_pos) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for x_pos",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.x_pos = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__y_pos => {
                                if !fields.insert(__FieldTag::__y_pos) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for y_pos",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.y_pos = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__width => {
                                if !fields.insert(__FieldTag::__width) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for width",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.width = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__height => {
                                if !fields.insert(__FieldTag::__height) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for height",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.height = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__widget => {
                                if !fields.insert(__FieldTag::__widget) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for widget",
                                    ));
                                }
                                result.widget =
                                    map.next_value::<std::option::Option<crate::model::Widget>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Tile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.x_pos) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("xPos", &__With(&self.x_pos))?;
            }
            if !wkt::internal::is_default(&self.y_pos) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("yPos", &__With(&self.y_pos))?;
            }
            if !wkt::internal::is_default(&self.width) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("width", &__With(&self.width))?;
            }
            if !wkt::internal::is_default(&self.height) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("height", &__With(&self.height))?;
            }
            if self.widget.is_some() {
                state.serialize_entry("widget", &self.widget)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Tile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Tile");
            debug_struct.field("x_pos", &self.x_pos);
            debug_struct.field("y_pos", &self.y_pos);
            debug_struct.field("width", &self.width);
            debug_struct.field("height", &self.height);
            debug_struct.field("widget", &self.widget);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A simplified layout that divides the available space into rows
/// and arranges a set of widgets horizontally in each row.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RowLayout {
    /// The rows of content to display.
    pub rows: std::vec::Vec<crate::model::row_layout::Row>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RowLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rows][crate::model::RowLayout::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::row_layout::Row>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RowLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.RowLayout"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RowLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RowLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rows" => Ok(__FieldTag::__rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RowLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RowLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::row_layout::Row>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RowLayout {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rows.is_empty() {
            state.serialize_entry("rows", &self.rows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RowLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RowLayout");
        debug_struct.field("rows", &self.rows);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RowLayout].
pub mod row_layout {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the layout properties and content for a row.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Row {
        /// The relative weight of this row. The row weight is used to adjust the
        /// height of rows on the screen (relative to peers). Greater the weight,
        /// greater the height of the row on the screen. If omitted, a value
        /// of 1 is used while rendering.
        pub weight: i64,

        /// The display widgets arranged horizontally in this row.
        pub widgets: std::vec::Vec<crate::model::Widget>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Row {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [weight][crate::model::row_layout::Row::weight].
        pub fn set_weight<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.weight = v.into();
            self
        }

        /// Sets the value of [widgets][crate::model::row_layout::Row::widgets].
        pub fn set_widgets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Widget>,
        {
            use std::iter::Iterator;
            self.widgets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Row {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.RowLayout.Row"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Row {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __weight,
                __widgets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Row")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "weight" => Ok(__FieldTag::__weight),
                                "widgets" => Ok(__FieldTag::__widgets),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Row;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Row")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__weight => {
                                if !fields.insert(__FieldTag::__weight) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for weight",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.weight = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__widgets => {
                                if !fields.insert(__FieldTag::__widgets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for widgets",
                                    ));
                                }
                                result.widgets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Widget>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Row {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.weight) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("weight", &__With(&self.weight))?;
            }
            if !self.widgets.is_empty() {
                state.serialize_entry("widgets", &self.widgets)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Row {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Row");
            debug_struct.field("weight", &self.weight);
            debug_struct.field("widgets", &self.widgets);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A simplified layout that divides the available space into vertical columns
/// and arranges a set of widgets vertically in each column.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ColumnLayout {
    /// The columns of content to display.
    pub columns: std::vec::Vec<crate::model::column_layout::Column>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::ColumnLayout::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::column_layout::Column>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ColumnLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ColumnLayout"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColumnLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColumnLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::column_layout::Column>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColumnLayout {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ColumnLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ColumnLayout");
        debug_struct.field("columns", &self.columns);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ColumnLayout].
pub mod column_layout {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the layout properties and content for a column.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Column {
        /// The relative weight of this column. The column weight is used to adjust
        /// the width of columns on the screen (relative to peers).
        /// Greater the weight, greater the width of the column on the screen.
        /// If omitted, a value of 1 is used while rendering.
        pub weight: i64,

        /// The display widgets arranged vertically in this column.
        pub widgets: std::vec::Vec<crate::model::Widget>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Column {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [weight][crate::model::column_layout::Column::weight].
        pub fn set_weight<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.weight = v.into();
            self
        }

        /// Sets the value of [widgets][crate::model::column_layout::Column::widgets].
        pub fn set_widgets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Widget>,
        {
            use std::iter::Iterator;
            self.widgets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Column {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.ColumnLayout.Column"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Column {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __weight,
                __widgets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Column")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "weight" => Ok(__FieldTag::__weight),
                                "widgets" => Ok(__FieldTag::__widgets),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Column;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Column")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__weight => {
                                if !fields.insert(__FieldTag::__weight) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for weight",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.weight = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__widgets => {
                                if !fields.insert(__FieldTag::__widgets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for widgets",
                                    ));
                                }
                                result.widgets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Widget>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Column {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.weight) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("weight", &__With(&self.weight))?;
            }
            if !self.widgets.is_empty() {
                state.serialize_entry("widgets", &self.widgets)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Column {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Column");
            debug_struct.field("weight", &self.weight);
            debug_struct.field("widgets", &self.widgets);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A widget that displays a stream of log.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LogsPanel {
    /// A filter that chooses which log entries to return.  See [Advanced Logs
    /// Queries](https://cloud.google.com/logging/docs/view/advanced-queries).
    /// Only log entries that match the filter are returned.  An empty filter
    /// matches all log entries.
    pub filter: std::string::String,

    /// The names of logging resources to collect logs for. Currently only projects
    /// are supported. If empty, the widget will default to the host project.
    pub resource_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogsPanel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::LogsPanel::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [resource_names][crate::model::LogsPanel::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LogsPanel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.LogsPanel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogsPanel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __resource_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogsPanel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogsPanel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogsPanel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogsPanel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LogsPanel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LogsPanel");
        debug_struct.field("filter", &self.filter);
        debug_struct.field("resource_names", &self.resource_names);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// TimeSeriesQuery collects the set of supported methods for querying time
/// series data from the Stackdriver metrics API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeriesQuery {
    /// The unit of data contained in fetched time series. If non-empty, this
    /// unit will override any unit that accompanies fetched data. The format is
    /// the same as the
    /// [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors)
    /// field in `MetricDescriptor`.
    pub unit_override: std::string::String,

    /// Optional. If set, Cloud Monitoring will treat the full query duration as
    /// the alignment period so that there will be only 1 output value.
    ///
    /// *Note: This could override the configured alignment period except for
    /// the cases where a series of data points are expected, like
    ///
    /// - XyChart
    /// - Scorecard's spark chart
    pub output_full_duration: bool,

    /// Parameters needed to obtain data for the chart.
    pub source: std::option::Option<crate::model::time_series_query::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [unit_override][crate::model::TimeSeriesQuery::unit_override].
    pub fn set_unit_override<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.unit_override = v.into();
        self
    }

    /// Sets the value of [output_full_duration][crate::model::TimeSeriesQuery::output_full_duration].
    pub fn set_output_full_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.output_full_duration = v.into();
        self
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::time_series_query::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesFilter(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesFilterRatio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_filter_ratio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesFilterRatio>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesFilterRatio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesFilterRatio`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_filter_ratio<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesFilterRatio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesFilterRatio(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesQueryLanguage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_query_language(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesQueryLanguage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesQueryLanguage`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_query_language<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesQueryLanguage(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `PrometheusQuery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn prometheus_query(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::PrometheusQuery(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `PrometheusQuery`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_prometheus_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::PrometheusQuery(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesQuery"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeriesQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_filter,
            __time_series_filter_ratio,
            __time_series_query_language,
            __prometheus_query,
            __unit_override,
            __output_full_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesFilter" => Ok(__FieldTag::__time_series_filter),
                            "time_series_filter" => Ok(__FieldTag::__time_series_filter),
                            "timeSeriesFilterRatio" => Ok(__FieldTag::__time_series_filter_ratio),
                            "time_series_filter_ratio" => {
                                Ok(__FieldTag::__time_series_filter_ratio)
                            }
                            "timeSeriesQueryLanguage" => {
                                Ok(__FieldTag::__time_series_query_language)
                            }
                            "time_series_query_language" => {
                                Ok(__FieldTag::__time_series_query_language)
                            }
                            "prometheusQuery" => Ok(__FieldTag::__prometheus_query),
                            "prometheus_query" => Ok(__FieldTag::__prometheus_query),
                            "unitOverride" => Ok(__FieldTag::__unit_override),
                            "unit_override" => Ok(__FieldTag::__unit_override),
                            "outputFullDuration" => Ok(__FieldTag::__output_full_duration),
                            "output_full_duration" => Ok(__FieldTag::__output_full_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeriesQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_filter => {
                            if !fields.insert(__FieldTag::__time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_filter",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.time_series_filter, latest field was timeSeriesFilter",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::TimeSeriesFilter(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeSeriesFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__time_series_filter_ratio => {
                            if !fields.insert(__FieldTag::__time_series_filter_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_filter_ratio",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.time_series_filter_ratio, latest field was timeSeriesFilterRatio",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::TimeSeriesFilterRatio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeSeriesFilterRatio>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__time_series_query_language => {
                            if !fields.insert(__FieldTag::__time_series_query_language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_query_language",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.time_series_query_language, latest field was timeSeriesQueryLanguage",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::TimeSeriesQueryLanguage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__prometheus_query => {
                            if !fields.insert(__FieldTag::__prometheus_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prometheus_query",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.prometheus_query, latest field was prometheusQuery",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::PrometheusQuery(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__unit_override => {
                            if !fields.insert(__FieldTag::__unit_override) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unit_override",
                                ));
                            }
                            result.unit_override = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_full_duration => {
                            if !fields.insert(__FieldTag::__output_full_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_full_duration",
                                ));
                            }
                            result.output_full_duration = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeriesQuery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.time_series_filter() {
            state.serialize_entry("timeSeriesFilter", value)?;
        }
        if let Some(value) = self.time_series_filter_ratio() {
            state.serialize_entry("timeSeriesFilterRatio", value)?;
        }
        if let Some(value) = self.time_series_query_language() {
            state.serialize_entry("timeSeriesQueryLanguage", value)?;
        }
        if let Some(value) = self.prometheus_query() {
            state.serialize_entry("prometheusQuery", value)?;
        }
        if !self.unit_override.is_empty() {
            state.serialize_entry("unitOverride", &self.unit_override)?;
        }
        if !wkt::internal::is_default(&self.output_full_duration) {
            state.serialize_entry("outputFullDuration", &self.output_full_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeSeriesQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeSeriesQuery");
        debug_struct.field("unit_override", &self.unit_override);
        debug_struct.field("output_full_duration", &self.output_full_duration);
        debug_struct.field("source", &self.source);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TimeSeriesQuery].
pub mod time_series_query {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters needed to obtain data for the chart.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Filter parameters to fetch time series.
        TimeSeriesFilter(std::boxed::Box<crate::model::TimeSeriesFilter>),
        /// Parameters to fetch a ratio between two time series filters.
        TimeSeriesFilterRatio(std::boxed::Box<crate::model::TimeSeriesFilterRatio>),
        /// A query used to fetch time series with MQL.
        TimeSeriesQueryLanguage(std::string::String),
        /// A query used to fetch time series with PromQL.
        PrometheusQuery(std::string::String),
    }
}

/// A filter that defines a subset of time series data that is displayed in a
/// widget. Time series data is fetched using the
/// [`ListTimeSeries`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
/// method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeriesFilter {
    /// Required. The [monitoring
    /// filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies
    /// the metric types, resources, and projects to query.
    pub filter: std::string::String,

    /// By default, the raw time series data is returned.
    /// Use this field to combine multiple time series for different views of the
    /// data.
    pub aggregation: std::option::Option<crate::model::Aggregation>,

    /// Apply a second aggregation after `aggregation` is applied.
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Selects an optional time series filter.
    pub output_filter: std::option::Option<crate::model::time_series_filter::OutputFilter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::TimeSeriesFilter::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [aggregation][crate::model::TimeSeriesFilter::aggregation].
    pub fn set_aggregation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.aggregation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregation][crate::model::TimeSeriesFilter::aggregation].
    pub fn set_or_clear_aggregation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.aggregation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::TimeSeriesFilter::secondary_aggregation].
    pub fn set_secondary_aggregation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.secondary_aggregation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_aggregation][crate::model::TimeSeriesFilter::secondary_aggregation].
    pub fn set_or_clear_secondary_aggregation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.secondary_aggregation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter].
    ///
    /// Note that all the setters affecting `output_filter` are mutually
    /// exclusive.
    pub fn set_output_filter<
        T: std::convert::Into<std::option::Option<crate::model::time_series_filter::OutputFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = v.into();
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// if it holds a `PickTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pick_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PickTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// to hold a `PickTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_pick_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::PickTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(v.into()),
        );
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// if it holds a `StatisticalTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn statistical_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// to hold a `StatisticalTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_statistical_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeriesFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __aggregation,
            __secondary_aggregation,
            __pick_time_series_filter,
            __statistical_time_series_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "aggregation" => Ok(__FieldTag::__aggregation),
                            "secondaryAggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "secondary_aggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "pickTimeSeriesFilter" => Ok(__FieldTag::__pick_time_series_filter),
                            "pick_time_series_filter" => Ok(__FieldTag::__pick_time_series_filter),
                            "statisticalTimeSeriesFilter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            "statistical_time_series_filter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeriesFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aggregation => {
                            if !fields.insert(__FieldTag::__aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation",
                                ));
                            }
                            result.aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__secondary_aggregation => {
                            if !fields.insert(__FieldTag::__secondary_aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_aggregation",
                                ));
                            }
                            result.secondary_aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__pick_time_series_filter => {
                            if !fields.insert(__FieldTag::__pick_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pick_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilter.pick_time_series_filter, latest field was pickTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PickTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__statistical_time_series_filter => {
                            if !fields.insert(__FieldTag::__statistical_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statistical_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilter.statistical_time_series_filter, latest field was statisticalTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeriesFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.aggregation.is_some() {
            state.serialize_entry("aggregation", &self.aggregation)?;
        }
        if self.secondary_aggregation.is_some() {
            state.serialize_entry("secondaryAggregation", &self.secondary_aggregation)?;
        }
        if let Some(value) = self.pick_time_series_filter() {
            state.serialize_entry("pickTimeSeriesFilter", value)?;
        }
        if let Some(value) = self.statistical_time_series_filter() {
            state.serialize_entry("statisticalTimeSeriesFilter", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeSeriesFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeSeriesFilter");
        debug_struct.field("filter", &self.filter);
        debug_struct.field("aggregation", &self.aggregation);
        debug_struct.field("secondary_aggregation", &self.secondary_aggregation);
        debug_struct.field("output_filter", &self.output_filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TimeSeriesFilter].
pub mod time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Selects an optional time series filter.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        PickTimeSeriesFilter(std::boxed::Box<crate::model::PickTimeSeriesFilter>),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        #[deprecated]
        StatisticalTimeSeriesFilter(std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>),
    }
}

/// A pair of time series filters that define a ratio computation. The output
/// time series is the pair-wise division of each aligned element from the
/// numerator and denominator time series.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeriesFilterRatio {
    /// The numerator of the ratio.
    pub numerator: std::option::Option<crate::model::time_series_filter_ratio::RatioPart>,

    /// The denominator of the ratio.
    pub denominator: std::option::Option<crate::model::time_series_filter_ratio::RatioPart>,

    /// Apply a second aggregation after the ratio is computed.
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    pub output_filter: std::option::Option<crate::model::time_series_filter_ratio::OutputFilter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesFilterRatio {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [numerator][crate::model::TimeSeriesFilterRatio::numerator].
    pub fn set_numerator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::time_series_filter_ratio::RatioPart>,
    {
        self.numerator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [numerator][crate::model::TimeSeriesFilterRatio::numerator].
    pub fn set_or_clear_numerator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::time_series_filter_ratio::RatioPart>,
    {
        self.numerator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [denominator][crate::model::TimeSeriesFilterRatio::denominator].
    pub fn set_denominator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::time_series_filter_ratio::RatioPart>,
    {
        self.denominator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [denominator][crate::model::TimeSeriesFilterRatio::denominator].
    pub fn set_or_clear_denominator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::time_series_filter_ratio::RatioPart>,
    {
        self.denominator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::TimeSeriesFilterRatio::secondary_aggregation].
    pub fn set_secondary_aggregation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.secondary_aggregation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_aggregation][crate::model::TimeSeriesFilterRatio::secondary_aggregation].
    pub fn set_or_clear_secondary_aggregation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.secondary_aggregation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter].
    ///
    /// Note that all the setters affecting `output_filter` are mutually
    /// exclusive.
    pub fn set_output_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::time_series_filter_ratio::OutputFilter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = v.into();
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// if it holds a `PickTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pick_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PickTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// to hold a `PickTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_pick_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::PickTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(v.into()),
        );
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// if it holds a `StatisticalTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn statistical_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// to hold a `StatisticalTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_statistical_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesFilterRatio {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilterRatio"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeriesFilterRatio {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __numerator,
            __denominator,
            __secondary_aggregation,
            __pick_time_series_filter,
            __statistical_time_series_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesFilterRatio")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "numerator" => Ok(__FieldTag::__numerator),
                            "denominator" => Ok(__FieldTag::__denominator),
                            "secondaryAggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "secondary_aggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "pickTimeSeriesFilter" => Ok(__FieldTag::__pick_time_series_filter),
                            "pick_time_series_filter" => Ok(__FieldTag::__pick_time_series_filter),
                            "statisticalTimeSeriesFilter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            "statistical_time_series_filter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeriesFilterRatio;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesFilterRatio")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__numerator => {
                            if !fields.insert(__FieldTag::__numerator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numerator",
                                ));
                            }
                            result.numerator = map.next_value::<std::option::Option<
                                crate::model::time_series_filter_ratio::RatioPart,
                            >>()?;
                        }
                        __FieldTag::__denominator => {
                            if !fields.insert(__FieldTag::__denominator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denominator",
                                ));
                            }
                            result.denominator = map.next_value::<std::option::Option<
                                crate::model::time_series_filter_ratio::RatioPart,
                            >>()?;
                        }
                        __FieldTag::__secondary_aggregation => {
                            if !fields.insert(__FieldTag::__secondary_aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_aggregation",
                                ));
                            }
                            result.secondary_aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__pick_time_series_filter => {
                            if !fields.insert(__FieldTag::__pick_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pick_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilterRatio.pick_time_series_filter, latest field was pickTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PickTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__statistical_time_series_filter => {
                            if !fields.insert(__FieldTag::__statistical_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statistical_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilterRatio.statistical_time_series_filter, latest field was statisticalTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeriesFilterRatio {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.numerator.is_some() {
            state.serialize_entry("numerator", &self.numerator)?;
        }
        if self.denominator.is_some() {
            state.serialize_entry("denominator", &self.denominator)?;
        }
        if self.secondary_aggregation.is_some() {
            state.serialize_entry("secondaryAggregation", &self.secondary_aggregation)?;
        }
        if let Some(value) = self.pick_time_series_filter() {
            state.serialize_entry("pickTimeSeriesFilter", value)?;
        }
        if let Some(value) = self.statistical_time_series_filter() {
            state.serialize_entry("statisticalTimeSeriesFilter", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeSeriesFilterRatio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeSeriesFilterRatio");
        debug_struct.field("numerator", &self.numerator);
        debug_struct.field("denominator", &self.denominator);
        debug_struct.field("secondary_aggregation", &self.secondary_aggregation);
        debug_struct.field("output_filter", &self.output_filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TimeSeriesFilterRatio].
pub mod time_series_filter_ratio {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a query to build the numerator or denominator of a
    /// TimeSeriesFilterRatio.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RatioPart {
        /// Required. The [monitoring
        /// filter](https://cloud.google.com/monitoring/api/v3/filters) that
        /// identifies the metric types, resources, and projects to query.
        pub filter: std::string::String,

        /// By default, the raw time series data is returned.
        /// Use this field to combine multiple time series for different views of the
        /// data.
        pub aggregation: std::option::Option<crate::model::Aggregation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RatioPart {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::time_series_filter_ratio::RatioPart::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }

        /// Sets the value of [aggregation][crate::model::time_series_filter_ratio::RatioPart::aggregation].
        pub fn set_aggregation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Aggregation>,
        {
            self.aggregation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [aggregation][crate::model::time_series_filter_ratio::RatioPart::aggregation].
        pub fn set_or_clear_aggregation<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Aggregation>,
        {
            self.aggregation = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RatioPart {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilterRatio.RatioPart"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RatioPart {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __filter,
                __aggregation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RatioPart")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "filter" => Ok(__FieldTag::__filter),
                                "aggregation" => Ok(__FieldTag::__aggregation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RatioPart;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RatioPart")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__aggregation => {
                                if !fields.insert(__FieldTag::__aggregation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aggregation",
                                    ));
                                }
                                result.aggregation = map
                                    .next_value::<std::option::Option<crate::model::Aggregation>>(
                                    )?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RatioPart {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.filter.is_empty() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if self.aggregation.is_some() {
                state.serialize_entry("aggregation", &self.aggregation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RatioPart {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RatioPart");
            debug_struct.field("filter", &self.filter);
            debug_struct.field("aggregation", &self.aggregation);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        PickTimeSeriesFilter(std::boxed::Box<crate::model::PickTimeSeriesFilter>),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        #[deprecated]
        StatisticalTimeSeriesFilter(std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>),
    }
}

/// Defines a threshold for categorizing time series values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Threshold {
    /// A label for the threshold.
    pub label: std::string::String,

    /// The value of the threshold. The value should be defined in the native scale
    /// of the metric.
    pub value: f64,

    /// The state color for this threshold. Color is not allowed in a XyChart.
    pub color: crate::model::threshold::Color,

    /// The direction for the current threshold. Direction is not allowed in a
    /// XyChart.
    pub direction: crate::model::threshold::Direction,

    /// The target axis to use for plotting the threshold. Target axis is not
    /// allowed in a Scorecard.
    pub target_axis: crate::model::threshold::TargetAxis,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Threshold {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label][crate::model::Threshold::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Threshold::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [color][crate::model::Threshold::color].
    pub fn set_color<T: std::convert::Into<crate::model::threshold::Color>>(
        mut self,
        v: T,
    ) -> Self {
        self.color = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::Threshold::direction].
    pub fn set_direction<T: std::convert::Into<crate::model::threshold::Direction>>(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [target_axis][crate::model::Threshold::target_axis].
    pub fn set_target_axis<T: std::convert::Into<crate::model::threshold::TargetAxis>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_axis = v.into();
        self
    }
}

impl wkt::message::Message for Threshold {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Threshold"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Threshold {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label,
            __value,
            __color,
            __direction,
            __target_axis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Threshold")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "label" => Ok(__FieldTag::__label),
                            "value" => Ok(__FieldTag::__value),
                            "color" => Ok(__FieldTag::__color),
                            "direction" => Ok(__FieldTag::__direction),
                            "targetAxis" => Ok(__FieldTag::__target_axis),
                            "target_axis" => Ok(__FieldTag::__target_axis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Threshold;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Threshold")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__color => {
                            if !fields.insert(__FieldTag::__color) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for color",
                                ));
                            }
                            result.color = map
                                .next_value::<std::option::Option<crate::model::threshold::Color>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map.next_value::<std::option::Option<crate::model::threshold::Direction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__target_axis => {
                            if !fields.insert(__FieldTag::__target_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_axis",
                                ));
                            }
                            result.target_axis = map.next_value::<std::option::Option<crate::model::threshold::TargetAxis>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Threshold {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !wkt::internal::is_default(&self.color) {
            state.serialize_entry("color", &self.color)?;
        }
        if !wkt::internal::is_default(&self.direction) {
            state.serialize_entry("direction", &self.direction)?;
        }
        if !wkt::internal::is_default(&self.target_axis) {
            state.serialize_entry("targetAxis", &self.target_axis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Threshold {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Threshold");
        debug_struct.field("label", &self.label);
        debug_struct.field("value", &self.value);
        debug_struct.field("color", &self.color);
        debug_struct.field("direction", &self.direction);
        debug_struct.field("target_axis", &self.target_axis);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Threshold].
pub mod threshold {
    #[allow(unused_imports)]
    use super::*;

    /// The color suggests an interpretation to the viewer when actual values cross
    /// the threshold. Comments on each color provide UX guidance on how users can
    /// be expected to interpret a given state color.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Color {
        /// Color is unspecified. Not allowed in well-formed requests.
        Unspecified,
        /// Crossing the threshold is "concerning" behavior.
        Yellow,
        /// Crossing the threshold is "emergency" behavior.
        Red,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Color::value] or
        /// [Color::name].
        UnknownValue(color::UnknownValue),
    }

    #[doc(hidden)]
    pub mod color {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Color {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Yellow => std::option::Option::Some(4),
                Self::Red => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COLOR_UNSPECIFIED"),
                Self::Yellow => std::option::Option::Some("YELLOW"),
                Self::Red => std::option::Option::Some("RED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Color {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Color {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Color {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                4 => Self::Yellow,
                6 => Self::Red,
                _ => Self::UnknownValue(color::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Color {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COLOR_UNSPECIFIED" => Self::Unspecified,
                "YELLOW" => Self::Yellow,
                "RED" => Self::Red,
                _ => Self::UnknownValue(color::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Color {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Yellow => serializer.serialize_i32(4),
                Self::Red => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Color {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Color>::new(
                ".google.monitoring.dashboard.v1.Threshold.Color",
            ))
        }
    }

    /// Whether the threshold is considered crossed by an actual value above or
    /// below its threshold value.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Not allowed in well-formed requests.
        Unspecified,
        /// The threshold will be considered crossed if the actual value is above
        /// the threshold value.
        Above,
        /// The threshold will be considered crossed if the actual value is below
        /// the threshold value.
        Below,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Above => std::option::Option::Some(1),
                Self::Below => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Above => std::option::Option::Some("ABOVE"),
                Self::Below => std::option::Option::Some("BELOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Above,
                2 => Self::Below,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "ABOVE" => Self::Above,
                "BELOW" => Self::Below,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Above => serializer.serialize_i32(1),
                Self::Below => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.monitoring.dashboard.v1.Threshold.Direction",
            ))
        }
    }

    /// An axis identifier.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetAxis {
        /// The target axis was not specified. Defaults to Y1.
        Unspecified,
        /// The y_axis (the right axis of chart).
        Y1,
        /// The y2_axis (the left axis of chart).
        Y2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TargetAxis::value] or
        /// [TargetAxis::name].
        UnknownValue(target_axis::UnknownValue),
    }

    #[doc(hidden)]
    pub mod target_axis {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TargetAxis {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Y1 => std::option::Option::Some(1),
                Self::Y2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARGET_AXIS_UNSPECIFIED"),
                Self::Y1 => std::option::Option::Some("Y1"),
                Self::Y2 => std::option::Option::Some("Y2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TargetAxis {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TargetAxis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TargetAxis {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Y1,
                2 => Self::Y2,
                _ => Self::UnknownValue(target_axis::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TargetAxis {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARGET_AXIS_UNSPECIFIED" => Self::Unspecified,
                "Y1" => Self::Y1,
                "Y2" => Self::Y2,
                _ => Self::UnknownValue(target_axis::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TargetAxis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Y1 => serializer.serialize_i32(1),
                Self::Y2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TargetAxis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetAxis>::new(
                ".google.monitoring.dashboard.v1.Threshold.TargetAxis",
            ))
        }
    }
}

/// A widget that displays timeseries data as a pie or a donut.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PieChart {
    /// Required. The queries for the chart's data.
    pub data_sets: std::vec::Vec<crate::model::pie_chart::PieChartDataSet>,

    /// Required. Indicates the visualization type for the PieChart.
    pub chart_type: crate::model::pie_chart::PieChartType,

    /// Optional. Indicates whether or not the pie chart should show slices' labels
    pub show_labels: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PieChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sets][crate::model::PieChart::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pie_chart::PieChartDataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [chart_type][crate::model::PieChart::chart_type].
    pub fn set_chart_type<T: std::convert::Into<crate::model::pie_chart::PieChartType>>(
        mut self,
        v: T,
    ) -> Self {
        self.chart_type = v.into();
        self
    }

    /// Sets the value of [show_labels][crate::model::PieChart::show_labels].
    pub fn set_show_labels<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_labels = v.into();
        self
    }
}

impl wkt::message::Message for PieChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.PieChart"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PieChart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sets,
            __chart_type,
            __show_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PieChart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSets" => Ok(__FieldTag::__data_sets),
                            "data_sets" => Ok(__FieldTag::__data_sets),
                            "chartType" => Ok(__FieldTag::__chart_type),
                            "chart_type" => Ok(__FieldTag::__chart_type),
                            "showLabels" => Ok(__FieldTag::__show_labels),
                            "show_labels" => Ok(__FieldTag::__show_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PieChart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PieChart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sets => {
                            if !fields.insert(__FieldTag::__data_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sets",
                                ));
                            }
                            result.data_sets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::pie_chart::PieChartDataSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__chart_type => {
                            if !fields.insert(__FieldTag::__chart_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chart_type",
                                ));
                            }
                            result.chart_type = map.next_value::<std::option::Option<crate::model::pie_chart::PieChartType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__show_labels => {
                            if !fields.insert(__FieldTag::__show_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_labels",
                                ));
                            }
                            result.show_labels = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PieChart {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_sets.is_empty() {
            state.serialize_entry("dataSets", &self.data_sets)?;
        }
        if !wkt::internal::is_default(&self.chart_type) {
            state.serialize_entry("chartType", &self.chart_type)?;
        }
        if !wkt::internal::is_default(&self.show_labels) {
            state.serialize_entry("showLabels", &self.show_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PieChart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PieChart");
        debug_struct.field("data_sets", &self.data_sets);
        debug_struct.field("chart_type", &self.chart_type);
        debug_struct.field("show_labels", &self.show_labels);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PieChart].
pub mod pie_chart {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PieChartDataSet {
        /// Required. The query for the PieChart. See,
        /// `google.monitoring.dashboard.v1.TimeSeriesQuery`.
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// Optional. A template for the name of the slice. This name will be
        /// displayed in the legend and the tooltip of the pie chart. It replaces the
        /// auto-generated names for the slices. For example, if the template is set
        /// to
        /// `${resource.labels.zone}`, the zone's value will be used for the name
        /// instead of the default name.
        pub slice_name_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query. For example, if the data is published once every 10
        /// minutes, the `min_alignment_period` should be at least 10 minutes. It
        /// would not make sense to fetch and align data at one minute intervals.
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PieChartDataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::pie_chart::PieChartDataSet::time_series_query].
        pub fn set_time_series_query<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TimeSeriesQuery>,
        {
            self.time_series_query = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time_series_query][crate::model::pie_chart::PieChartDataSet::time_series_query].
        pub fn set_or_clear_time_series_query<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TimeSeriesQuery>,
        {
            self.time_series_query = v.map(|x| x.into());
            self
        }

        /// Sets the value of [slice_name_template][crate::model::pie_chart::PieChartDataSet::slice_name_template].
        pub fn set_slice_name_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.slice_name_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::pie_chart::PieChartDataSet::min_alignment_period].
        pub fn set_min_alignment_period<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_alignment_period][crate::model::pie_chart::PieChartDataSet::min_alignment_period].
        pub fn set_or_clear_min_alignment_period<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PieChartDataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.PieChart.PieChartDataSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PieChartDataSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time_series_query,
                __slice_name_template,
                __min_alignment_period,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PieChartDataSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                                "time_series_query" => Ok(__FieldTag::__time_series_query),
                                "sliceNameTemplate" => Ok(__FieldTag::__slice_name_template),
                                "slice_name_template" => Ok(__FieldTag::__slice_name_template),
                                "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                                "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PieChartDataSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PieChartDataSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time_series_query => {
                                if !fields.insert(__FieldTag::__time_series_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_series_query",
                                    ));
                                }
                                result.time_series_query = map.next_value::<std::option::Option<crate::model::TimeSeriesQuery>>()?
                                    ;
                            }
                            __FieldTag::__slice_name_template => {
                                if !fields.insert(__FieldTag::__slice_name_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for slice_name_template",
                                    ));
                                }
                                result.slice_name_template = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__min_alignment_period => {
                                if !fields.insert(__FieldTag::__min_alignment_period) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_alignment_period",
                                    ));
                                }
                                result.min_alignment_period =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PieChartDataSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.time_series_query.is_some() {
                state.serialize_entry("timeSeriesQuery", &self.time_series_query)?;
            }
            if !self.slice_name_template.is_empty() {
                state.serialize_entry("sliceNameTemplate", &self.slice_name_template)?;
            }
            if self.min_alignment_period.is_some() {
                state.serialize_entry("minAlignmentPeriod", &self.min_alignment_period)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PieChartDataSet {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PieChartDataSet");
            debug_struct.field("time_series_query", &self.time_series_query);
            debug_struct.field("slice_name_template", &self.slice_name_template);
            debug_struct.field("min_alignment_period", &self.min_alignment_period);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Types for the pie chart.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PieChartType {
        /// The zero value. No type specified. Do not use.
        Unspecified,
        /// A Pie type PieChart.
        Pie,
        /// Similar to PIE, but the DONUT type PieChart has a hole in the middle.
        Donut,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PieChartType::value] or
        /// [PieChartType::name].
        UnknownValue(pie_chart_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod pie_chart_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PieChartType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pie => std::option::Option::Some(1),
                Self::Donut => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PIE_CHART_TYPE_UNSPECIFIED"),
                Self::Pie => std::option::Option::Some("PIE"),
                Self::Donut => std::option::Option::Some("DONUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PieChartType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PieChartType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PieChartType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pie,
                2 => Self::Donut,
                _ => Self::UnknownValue(pie_chart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PieChartType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PIE_CHART_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PIE" => Self::Pie,
                "DONUT" => Self::Donut,
                _ => Self::UnknownValue(pie_chart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PieChartType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pie => serializer.serialize_i32(1),
                Self::Donut => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PieChartType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PieChartType>::new(
                ".google.monitoring.dashboard.v1.PieChart.PieChartType",
            ))
        }
    }
}

/// A widget showing the latest value of a metric, and how this value relates to
/// one or more thresholds.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Scorecard {
    /// Required. Fields for querying time series data from the
    /// Stackdriver metrics API.
    pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

    /// The thresholds used to determine the state of the scorecard given the
    /// time series' current value. For an actual value x, the scorecard is in a
    /// danger state if x is less than or equal to a danger threshold that triggers
    /// below, or greater than or equal to a danger threshold that triggers above.
    /// Similarly, if x is above/below a warning threshold that triggers
    /// above/below, then the scorecard is in a warning state - unless x also puts
    /// it in a danger state. (Danger trumps warning.)
    ///
    /// As an example, consider a scorecard with the following four thresholds:
    ///
    /// ```norust
    /// {
    ///   value: 90,
    ///   category: 'DANGER',
    ///   trigger: 'ABOVE',
    /// },
    /// {
    ///   value: 70,
    ///   category: 'WARNING',
    ///   trigger: 'ABOVE',
    /// },
    /// {
    ///   value: 10,
    ///   category: 'DANGER',
    ///   trigger: 'BELOW',
    /// },
    /// {
    ///   value: 20,
    ///   category: 'WARNING',
    ///   trigger: 'BELOW',
    /// }
    /// ```
    ///
    /// Then: values less than or equal to 10 would put the scorecard in a DANGER
    /// state, values greater than 10 but less than or equal to 20 a WARNING state,
    /// values strictly between 20 and 70 an OK state, values greater than or equal
    /// to 70 but less than 90 a WARNING state, and values greater than or equal to
    /// 90 a DANGER state.
    pub thresholds: std::vec::Vec<crate::model::Threshold>,

    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    pub data_view: std::option::Option<crate::model::scorecard::DataView>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Scorecard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_query][crate::model::Scorecard::time_series_query].
    pub fn set_time_series_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSeriesQuery>,
    {
        self.time_series_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_series_query][crate::model::Scorecard::time_series_query].
    pub fn set_or_clear_time_series_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSeriesQuery>,
    {
        self.time_series_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [thresholds][crate::model::Scorecard::thresholds].
    pub fn set_thresholds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Threshold>,
    {
        use std::iter::Iterator;
        self.thresholds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view].
    ///
    /// Note that all the setters affecting `data_view` are mutually
    /// exclusive.
    pub fn set_data_view<
        T: std::convert::Into<std::option::Option<crate::model::scorecard::DataView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view = v.into();
        self
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `GaugeView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gauge_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scorecard::GaugeView>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::GaugeView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `GaugeView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_gauge_view<
        T: std::convert::Into<std::boxed::Box<crate::model::scorecard::GaugeView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::GaugeView(v.into()));
        self
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `SparkChartView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_chart_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scorecard::SparkChartView>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::SparkChartView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `SparkChartView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_spark_chart_view<
        T: std::convert::Into<std::boxed::Box<crate::model::scorecard::SparkChartView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::SparkChartView(v.into()));
        self
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `BlankView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn blank_view(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::BlankView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `BlankView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_blank_view<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::BlankView(v.into()));
        self
    }
}

impl wkt::message::Message for Scorecard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Scorecard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_query,
            __gauge_view,
            __spark_chart_view,
            __blank_view,
            __thresholds,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Scorecard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                            "time_series_query" => Ok(__FieldTag::__time_series_query),
                            "gaugeView" => Ok(__FieldTag::__gauge_view),
                            "gauge_view" => Ok(__FieldTag::__gauge_view),
                            "sparkChartView" => Ok(__FieldTag::__spark_chart_view),
                            "spark_chart_view" => Ok(__FieldTag::__spark_chart_view),
                            "blankView" => Ok(__FieldTag::__blank_view),
                            "blank_view" => Ok(__FieldTag::__blank_view),
                            "thresholds" => Ok(__FieldTag::__thresholds),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Scorecard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Scorecard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_query => {
                            if !fields.insert(__FieldTag::__time_series_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_query",
                                ));
                            }
                            result.time_series_query = map
                                .next_value::<std::option::Option<crate::model::TimeSeriesQuery>>(
                                )?;
                        }
                        __FieldTag::__gauge_view => {
                            if !fields.insert(__FieldTag::__gauge_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gauge_view",
                                ));
                            }
                            if result.data_view.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_view`, a oneof with full ID .google.monitoring.dashboard.v1.Scorecard.gauge_view, latest field was gaugeView",
                                ));
                            }
                            result.data_view = std::option::Option::Some(
                                crate::model::scorecard::DataView::GaugeView(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::scorecard::GaugeView>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_chart_view => {
                            if !fields.insert(__FieldTag::__spark_chart_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_chart_view",
                                ));
                            }
                            if result.data_view.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_view`, a oneof with full ID .google.monitoring.dashboard.v1.Scorecard.spark_chart_view, latest field was sparkChartView",
                                ));
                            }
                            result.data_view = std::option::Option::Some(
                                crate::model::scorecard::DataView::SparkChartView(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::scorecard::SparkChartView>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__blank_view => {
                            if !fields.insert(__FieldTag::__blank_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blank_view",
                                ));
                            }
                            if result.data_view.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_view`, a oneof with full ID .google.monitoring.dashboard.v1.Scorecard.blank_view, latest field was blankView",
                                ));
                            }
                            result.data_view = std::option::Option::Some(
                                crate::model::scorecard::DataView::BlankView(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__thresholds => {
                            if !fields.insert(__FieldTag::__thresholds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for thresholds",
                                ));
                            }
                            result.thresholds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Threshold>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Scorecard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.time_series_query.is_some() {
            state.serialize_entry("timeSeriesQuery", &self.time_series_query)?;
        }
        if let Some(value) = self.gauge_view() {
            state.serialize_entry("gaugeView", value)?;
        }
        if let Some(value) = self.spark_chart_view() {
            state.serialize_entry("sparkChartView", value)?;
        }
        if let Some(value) = self.blank_view() {
            state.serialize_entry("blankView", value)?;
        }
        if !self.thresholds.is_empty() {
            state.serialize_entry("thresholds", &self.thresholds)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Scorecard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Scorecard");
        debug_struct.field("time_series_query", &self.time_series_query);
        debug_struct.field("thresholds", &self.thresholds);
        debug_struct.field("data_view", &self.data_view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Scorecard].
pub mod scorecard {
    #[allow(unused_imports)]
    use super::*;

    /// A gauge chart shows where the current value sits within a pre-defined
    /// range. The upper and lower bounds should define the possible range of
    /// values for the scorecard's query (inclusive).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GaugeView {
        /// The lower bound for this gauge chart. The value of the chart should
        /// always be greater than or equal to this.
        pub lower_bound: f64,

        /// The upper bound for this gauge chart. The value of the chart should
        /// always be less than or equal to this.
        pub upper_bound: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GaugeView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lower_bound][crate::model::scorecard::GaugeView::lower_bound].
        pub fn set_lower_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.lower_bound = v.into();
            self
        }

        /// Sets the value of [upper_bound][crate::model::scorecard::GaugeView::upper_bound].
        pub fn set_upper_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.upper_bound = v.into();
            self
        }
    }

    impl wkt::message::Message for GaugeView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard.GaugeView"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GaugeView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __lower_bound,
                __upper_bound,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GaugeView")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lowerBound" => Ok(__FieldTag::__lower_bound),
                                "lower_bound" => Ok(__FieldTag::__lower_bound),
                                "upperBound" => Ok(__FieldTag::__upper_bound),
                                "upper_bound" => Ok(__FieldTag::__upper_bound),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GaugeView;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GaugeView")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__lower_bound => {
                                if !fields.insert(__FieldTag::__lower_bound) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lower_bound",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.lower_bound =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__upper_bound => {
                                if !fields.insert(__FieldTag::__upper_bound) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for upper_bound",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.upper_bound =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GaugeView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.lower_bound) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("lowerBound", &__With(&self.lower_bound))?;
            }
            if !wkt::internal::is_default(&self.upper_bound) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("upperBound", &__With(&self.upper_bound))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GaugeView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GaugeView");
            debug_struct.field("lower_bound", &self.lower_bound);
            debug_struct.field("upper_bound", &self.upper_bound);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A sparkChart is a small chart suitable for inclusion in a table-cell or
    /// inline in text. This message contains the configuration for a sparkChart
    /// to show up on a Scorecard, showing recent trends of the scorecard's
    /// timeseries.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SparkChartView {
        /// Required. The type of sparkchart to show in this chartView.
        pub spark_chart_type: crate::model::SparkChartType,

        /// The lower bound on data point frequency in the chart implemented by
        /// specifying the minimum alignment period to use in a time series query.
        /// For example, if the data is published once every 10 minutes it would not
        /// make sense to fetch and align data at one minute intervals. This field is
        /// optional and exists only as a hint.
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SparkChartView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [spark_chart_type][crate::model::scorecard::SparkChartView::spark_chart_type].
        pub fn set_spark_chart_type<T: std::convert::Into<crate::model::SparkChartType>>(
            mut self,
            v: T,
        ) -> Self {
            self.spark_chart_type = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::scorecard::SparkChartView::min_alignment_period].
        pub fn set_min_alignment_period<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_alignment_period][crate::model::scorecard::SparkChartView::min_alignment_period].
        pub fn set_or_clear_min_alignment_period<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SparkChartView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard.SparkChartView"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SparkChartView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __spark_chart_type,
                __min_alignment_period,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SparkChartView")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sparkChartType" => Ok(__FieldTag::__spark_chart_type),
                                "spark_chart_type" => Ok(__FieldTag::__spark_chart_type),
                                "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                                "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SparkChartView;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SparkChartView")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__spark_chart_type => {
                                if !fields.insert(__FieldTag::__spark_chart_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for spark_chart_type",
                                    ));
                                }
                                result.spark_chart_type = map.next_value::<std::option::Option<crate::model::SparkChartType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__min_alignment_period => {
                                if !fields.insert(__FieldTag::__min_alignment_period) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_alignment_period",
                                    ));
                                }
                                result.min_alignment_period =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SparkChartView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.spark_chart_type) {
                state.serialize_entry("sparkChartType", &self.spark_chart_type)?;
            }
            if self.min_alignment_period.is_some() {
                state.serialize_entry("minAlignmentPeriod", &self.min_alignment_period)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SparkChartView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SparkChartView");
            debug_struct.field("spark_chart_type", &self.spark_chart_type);
            debug_struct.field("min_alignment_period", &self.min_alignment_period);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataView {
        /// Will cause the scorecard to show a gauge chart.
        GaugeView(std::boxed::Box<crate::model::scorecard::GaugeView>),
        /// Will cause the scorecard to show a spark chart.
        SparkChartView(std::boxed::Box<crate::model::scorecard::SparkChartView>),
        /// Will cause the `Scorecard` to show only the value, with no indicator to
        /// its value relative to its thresholds.
        BlankView(std::boxed::Box<wkt::Empty>),
    }
}

/// A widget that defines a new section header. Sections populate a table of
/// contents and allow easier navigation of long-form content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SectionHeader {
    /// The subtitle of the section
    pub subtitle: std::string::String,

    /// Whether to insert a divider below the section in the table of contents
    pub divider_below: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SectionHeader {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subtitle][crate::model::SectionHeader::subtitle].
    pub fn set_subtitle<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subtitle = v.into();
        self
    }

    /// Sets the value of [divider_below][crate::model::SectionHeader::divider_below].
    pub fn set_divider_below<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.divider_below = v.into();
        self
    }
}

impl wkt::message::Message for SectionHeader {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.SectionHeader"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SectionHeader {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subtitle,
            __divider_below,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SectionHeader")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subtitle" => Ok(__FieldTag::__subtitle),
                            "dividerBelow" => Ok(__FieldTag::__divider_below),
                            "divider_below" => Ok(__FieldTag::__divider_below),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SectionHeader;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SectionHeader")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subtitle => {
                            if !fields.insert(__FieldTag::__subtitle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subtitle",
                                ));
                            }
                            result.subtitle = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__divider_below => {
                            if !fields.insert(__FieldTag::__divider_below) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for divider_below",
                                ));
                            }
                            result.divider_below = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SectionHeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subtitle.is_empty() {
            state.serialize_entry("subtitle", &self.subtitle)?;
        }
        if !wkt::internal::is_default(&self.divider_below) {
            state.serialize_entry("dividerBelow", &self.divider_below)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SectionHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SectionHeader");
        debug_struct.field("subtitle", &self.subtitle);
        debug_struct.field("divider_below", &self.divider_below);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A widget that groups the other widgets by using a dropdown menu. All widgets
/// that are within the area spanned by the grouping widget are considered
/// member widgets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SingleViewGroup {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SingleViewGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SingleViewGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.SingleViewGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SingleViewGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SingleViewGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SingleViewGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SingleViewGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SingleViewGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SingleViewGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SingleViewGroup");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A table that displays time series data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeriesTable {
    /// Required. The data displayed in this table.
    pub data_sets: std::vec::Vec<crate::model::time_series_table::TableDataSet>,

    /// Optional. Store rendering strategy
    pub metric_visualization: crate::model::time_series_table::MetricVisualization,

    /// Optional. The list of the persistent column settings for the table.
    pub column_settings: std::vec::Vec<crate::model::time_series_table::ColumnSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sets][crate::model::TimeSeriesTable::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_table::TableDataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metric_visualization][crate::model::TimeSeriesTable::metric_visualization].
    pub fn set_metric_visualization<
        T: std::convert::Into<crate::model::time_series_table::MetricVisualization>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_visualization = v.into();
        self
    }

    /// Sets the value of [column_settings][crate::model::TimeSeriesTable::column_settings].
    pub fn set_column_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_table::ColumnSettings>,
    {
        use std::iter::Iterator;
        self.column_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeriesTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sets,
            __metric_visualization,
            __column_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSets" => Ok(__FieldTag::__data_sets),
                            "data_sets" => Ok(__FieldTag::__data_sets),
                            "metricVisualization" => Ok(__FieldTag::__metric_visualization),
                            "metric_visualization" => Ok(__FieldTag::__metric_visualization),
                            "columnSettings" => Ok(__FieldTag::__column_settings),
                            "column_settings" => Ok(__FieldTag::__column_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeriesTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sets => {
                            if !fields.insert(__FieldTag::__data_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sets",
                                ));
                            }
                            result.data_sets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::time_series_table::TableDataSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric_visualization => {
                            if !fields.insert(__FieldTag::__metric_visualization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_visualization",
                                ));
                            }
                            result.metric_visualization = map
                                .next_value::<std::option::Option<
                                    crate::model::time_series_table::MetricVisualization,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__column_settings => {
                            if !fields.insert(__FieldTag::__column_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_settings",
                                ));
                            }
                            result.column_settings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::time_series_table::ColumnSettings>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeriesTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_sets.is_empty() {
            state.serialize_entry("dataSets", &self.data_sets)?;
        }
        if !wkt::internal::is_default(&self.metric_visualization) {
            state.serialize_entry("metricVisualization", &self.metric_visualization)?;
        }
        if !self.column_settings.is_empty() {
            state.serialize_entry("columnSettings", &self.column_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeSeriesTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeSeriesTable");
        debug_struct.field("data_sets", &self.data_sets);
        debug_struct.field("metric_visualization", &self.metric_visualization);
        debug_struct.field("column_settings", &self.column_settings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TimeSeriesTable].
pub mod time_series_table {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition with table options.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TableDataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// Optional. A template string for naming `TimeSeries` in the resulting data
        /// set. This should be a string with interpolations of the form
        /// `${label_name}`, which will resolve to the label's value i.e.
        /// "${resource.labels.project_id}."
        pub table_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        /// Optional. Table display options for configuring how the table is
        /// rendered.
        pub table_display_options: std::option::Option<crate::model::TableDisplayOptions>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TableDataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::time_series_table::TableDataSet::time_series_query].
        pub fn set_time_series_query<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TimeSeriesQuery>,
        {
            self.time_series_query = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time_series_query][crate::model::time_series_table::TableDataSet::time_series_query].
        pub fn set_or_clear_time_series_query<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TimeSeriesQuery>,
        {
            self.time_series_query = v.map(|x| x.into());
            self
        }

        /// Sets the value of [table_template][crate::model::time_series_table::TableDataSet::table_template].
        pub fn set_table_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.table_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::time_series_table::TableDataSet::min_alignment_period].
        pub fn set_min_alignment_period<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_alignment_period][crate::model::time_series_table::TableDataSet::min_alignment_period].
        pub fn set_or_clear_min_alignment_period<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = v.map(|x| x.into());
            self
        }

        /// Sets the value of [table_display_options][crate::model::time_series_table::TableDataSet::table_display_options].
        pub fn set_table_display_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TableDisplayOptions>,
        {
            self.table_display_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [table_display_options][crate::model::time_series_table::TableDataSet::table_display_options].
        pub fn set_or_clear_table_display_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TableDisplayOptions>,
        {
            self.table_display_options = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TableDataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable.TableDataSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TableDataSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time_series_query,
                __table_template,
                __min_alignment_period,
                __table_display_options,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TableDataSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                                "time_series_query" => Ok(__FieldTag::__time_series_query),
                                "tableTemplate" => Ok(__FieldTag::__table_template),
                                "table_template" => Ok(__FieldTag::__table_template),
                                "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                                "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                                "tableDisplayOptions" => Ok(__FieldTag::__table_display_options),
                                "table_display_options" => Ok(__FieldTag::__table_display_options),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TableDataSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TableDataSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time_series_query => {
                                if !fields.insert(__FieldTag::__time_series_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_series_query",
                                    ));
                                }
                                result.time_series_query = map.next_value::<std::option::Option<crate::model::TimeSeriesQuery>>()?
                                    ;
                            }
                            __FieldTag::__table_template => {
                                if !fields.insert(__FieldTag::__table_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_template",
                                    ));
                                }
                                result.table_template = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__min_alignment_period => {
                                if !fields.insert(__FieldTag::__min_alignment_period) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_alignment_period",
                                    ));
                                }
                                result.min_alignment_period =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__table_display_options => {
                                if !fields.insert(__FieldTag::__table_display_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_display_options",
                                    ));
                                }
                                result.table_display_options = map.next_value::<std::option::Option<crate::model::TableDisplayOptions>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TableDataSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.time_series_query.is_some() {
                state.serialize_entry("timeSeriesQuery", &self.time_series_query)?;
            }
            if !self.table_template.is_empty() {
                state.serialize_entry("tableTemplate", &self.table_template)?;
            }
            if self.min_alignment_period.is_some() {
                state.serialize_entry("minAlignmentPeriod", &self.min_alignment_period)?;
            }
            if self.table_display_options.is_some() {
                state.serialize_entry("tableDisplayOptions", &self.table_display_options)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TableDataSet {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TableDataSet");
            debug_struct.field("time_series_query", &self.time_series_query);
            debug_struct.field("table_template", &self.table_template);
            debug_struct.field("min_alignment_period", &self.min_alignment_period);
            debug_struct.field("table_display_options", &self.table_display_options);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The persistent settings for a table's columns.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ColumnSettings {
        /// Required. The id of the column.
        pub column: std::string::String,

        /// Required. Whether the column should be visible on page load.
        pub visible: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ColumnSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [column][crate::model::time_series_table::ColumnSettings::column].
        pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }

        /// Sets the value of [visible][crate::model::time_series_table::ColumnSettings::visible].
        pub fn set_visible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.visible = v.into();
            self
        }
    }

    impl wkt::message::Message for ColumnSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable.ColumnSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ColumnSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __column,
                __visible,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ColumnSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "column" => Ok(__FieldTag::__column),
                                "visible" => Ok(__FieldTag::__visible),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ColumnSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ColumnSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__column => {
                                if !fields.insert(__FieldTag::__column) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for column",
                                    ));
                                }
                                result.column = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__visible => {
                                if !fields.insert(__FieldTag::__visible) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for visible",
                                    ));
                                }
                                result.visible = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ColumnSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.column.is_empty() {
                state.serialize_entry("column", &self.column)?;
            }
            if !wkt::internal::is_default(&self.visible) {
                state.serialize_entry("visible", &self.visible)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ColumnSettings {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ColumnSettings");
            debug_struct.field("column", &self.column);
            debug_struct.field("visible", &self.visible);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Enum for metric metric_visualization
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MetricVisualization {
        /// Unspecified state
        Unspecified,
        /// Default text rendering
        Number,
        /// Horizontal bar rendering
        Bar,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MetricVisualization::value] or
        /// [MetricVisualization::name].
        UnknownValue(metric_visualization::UnknownValue),
    }

    #[doc(hidden)]
    pub mod metric_visualization {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MetricVisualization {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Number => std::option::Option::Some(1),
                Self::Bar => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METRIC_VISUALIZATION_UNSPECIFIED"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Bar => std::option::Option::Some("BAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MetricVisualization {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MetricVisualization {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MetricVisualization {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Number,
                2 => Self::Bar,
                _ => Self::UnknownValue(metric_visualization::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MetricVisualization {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METRIC_VISUALIZATION_UNSPECIFIED" => Self::Unspecified,
                "NUMBER" => Self::Number,
                "BAR" => Self::Bar,
                _ => Self::UnknownValue(metric_visualization::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MetricVisualization {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Number => serializer.serialize_i32(1),
                Self::Bar => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MetricVisualization {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetricVisualization>::new(
                ".google.monitoring.dashboard.v1.TimeSeriesTable.MetricVisualization",
            ))
        }
    }
}

/// Table display options that can be reused.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TableDisplayOptions {
    /// Optional. This field is unused and has been replaced by
    /// TimeSeriesTable.column_settings
    #[deprecated]
    pub shown_columns: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableDisplayOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shown_columns][crate::model::TableDisplayOptions::shown_columns].
    #[deprecated]
    pub fn set_shown_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.shown_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableDisplayOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TableDisplayOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableDisplayOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __shown_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableDisplayOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shownColumns" => Ok(__FieldTag::__shown_columns),
                            "shown_columns" => Ok(__FieldTag::__shown_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableDisplayOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableDisplayOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__shown_columns => {
                            if !fields.insert(__FieldTag::__shown_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shown_columns",
                                ));
                            }
                            result.shown_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableDisplayOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.shown_columns.is_empty() {
            state.serialize_entry("shownColumns", &self.shown_columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TableDisplayOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableDisplayOptions");
        debug_struct.field("shown_columns", &self.shown_columns);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A widget that displays textual content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Text {
    /// The text content to be displayed.
    pub content: std::string::String,

    /// How the text content is formatted.
    pub format: crate::model::text::Format,

    /// How the text is styled
    pub style: std::option::Option<crate::model::text::TextStyle>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Text {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::Text::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Text::format].
    pub fn set_format<T: std::convert::Into<crate::model::text::Format>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [style][crate::model::Text::style].
    pub fn set_style<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text::TextStyle>,
    {
        self.style = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [style][crate::model::Text::style].
    pub fn set_or_clear_style<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text::TextStyle>,
    {
        self.style = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Text {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Text"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Text {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __format,
            __style,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Text")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "format" => Ok(__FieldTag::__format),
                            "style" => Ok(__FieldTag::__style),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Text;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Text")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<crate::model::text::Format>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__style => {
                            if !fields.insert(__FieldTag::__style) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for style",
                                ));
                            }
                            result.style = map
                                .next_value::<std::option::Option<crate::model::text::TextStyle>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Text {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.format) {
            state.serialize_entry("format", &self.format)?;
        }
        if self.style.is_some() {
            state.serialize_entry("style", &self.style)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Text {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Text");
        debug_struct.field("content", &self.content);
        debug_struct.field("format", &self.format);
        debug_struct.field("style", &self.style);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Text].
pub mod text {
    #[allow(unused_imports)]
    use super::*;

    /// Properties that determine how the title and content are styled
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TextStyle {
        /// The background color as a hex string. "#RRGGBB" or "#RGB"
        pub background_color: std::string::String,

        /// The text color as a hex string. "#RRGGBB" or "#RGB"
        pub text_color: std::string::String,

        /// The horizontal alignment of both the title and content
        pub horizontal_alignment: crate::model::text::text_style::HorizontalAlignment,

        /// The vertical alignment of both the title and content
        pub vertical_alignment: crate::model::text::text_style::VerticalAlignment,

        /// The amount of padding around the widget
        pub padding: crate::model::text::text_style::PaddingSize,

        /// Font sizes for both the title and content. The title will still be larger
        /// relative to the content.
        pub font_size: crate::model::text::text_style::FontSize,

        /// The pointer location for this widget (also sometimes called a "tail")
        pub pointer_location: crate::model::text::text_style::PointerLocation,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextStyle {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [background_color][crate::model::text::TextStyle::background_color].
        pub fn set_background_color<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.background_color = v.into();
            self
        }

        /// Sets the value of [text_color][crate::model::text::TextStyle::text_color].
        pub fn set_text_color<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text_color = v.into();
            self
        }

        /// Sets the value of [horizontal_alignment][crate::model::text::TextStyle::horizontal_alignment].
        pub fn set_horizontal_alignment<
            T: std::convert::Into<crate::model::text::text_style::HorizontalAlignment>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.horizontal_alignment = v.into();
            self
        }

        /// Sets the value of [vertical_alignment][crate::model::text::TextStyle::vertical_alignment].
        pub fn set_vertical_alignment<
            T: std::convert::Into<crate::model::text::text_style::VerticalAlignment>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vertical_alignment = v.into();
            self
        }

        /// Sets the value of [padding][crate::model::text::TextStyle::padding].
        pub fn set_padding<T: std::convert::Into<crate::model::text::text_style::PaddingSize>>(
            mut self,
            v: T,
        ) -> Self {
            self.padding = v.into();
            self
        }

        /// Sets the value of [font_size][crate::model::text::TextStyle::font_size].
        pub fn set_font_size<T: std::convert::Into<crate::model::text::text_style::FontSize>>(
            mut self,
            v: T,
        ) -> Self {
            self.font_size = v.into();
            self
        }

        /// Sets the value of [pointer_location][crate::model::text::TextStyle::pointer_location].
        pub fn set_pointer_location<
            T: std::convert::Into<crate::model::text::text_style::PointerLocation>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.pointer_location = v.into();
            self
        }
    }

    impl wkt::message::Message for TextStyle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Text.TextStyle"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TextStyle {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __background_color,
                __text_color,
                __horizontal_alignment,
                __vertical_alignment,
                __padding,
                __font_size,
                __pointer_location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TextStyle")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "backgroundColor" => Ok(__FieldTag::__background_color),
                                "background_color" => Ok(__FieldTag::__background_color),
                                "textColor" => Ok(__FieldTag::__text_color),
                                "text_color" => Ok(__FieldTag::__text_color),
                                "horizontalAlignment" => Ok(__FieldTag::__horizontal_alignment),
                                "horizontal_alignment" => Ok(__FieldTag::__horizontal_alignment),
                                "verticalAlignment" => Ok(__FieldTag::__vertical_alignment),
                                "vertical_alignment" => Ok(__FieldTag::__vertical_alignment),
                                "padding" => Ok(__FieldTag::__padding),
                                "fontSize" => Ok(__FieldTag::__font_size),
                                "font_size" => Ok(__FieldTag::__font_size),
                                "pointerLocation" => Ok(__FieldTag::__pointer_location),
                                "pointer_location" => Ok(__FieldTag::__pointer_location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TextStyle;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TextStyle")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__background_color => {
                                if !fields.insert(__FieldTag::__background_color) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for background_color",
                                    ));
                                }
                                result.background_color = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text_color => {
                                if !fields.insert(__FieldTag::__text_color) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_color",
                                    ));
                                }
                                result.text_color = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__horizontal_alignment => {
                                if !fields.insert(__FieldTag::__horizontal_alignment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for horizontal_alignment",
                                    ));
                                }
                                result.horizontal_alignment = map
                                    .next_value::<std::option::Option<
                                        crate::model::text::text_style::HorizontalAlignment,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__vertical_alignment => {
                                if !fields.insert(__FieldTag::__vertical_alignment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vertical_alignment",
                                    ));
                                }
                                result.vertical_alignment = map
                                    .next_value::<std::option::Option<
                                        crate::model::text::text_style::VerticalAlignment,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__padding => {
                                if !fields.insert(__FieldTag::__padding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for padding",
                                    ));
                                }
                                result.padding = map
                                    .next_value::<std::option::Option<
                                        crate::model::text::text_style::PaddingSize,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__font_size => {
                                if !fields.insert(__FieldTag::__font_size) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for font_size",
                                    ));
                                }
                                result.font_size =
                                    map.next_value::<std::option::Option<
                                        crate::model::text::text_style::FontSize,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pointer_location => {
                                if !fields.insert(__FieldTag::__pointer_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pointer_location",
                                    ));
                                }
                                result.pointer_location = map
                                    .next_value::<std::option::Option<
                                        crate::model::text::text_style::PointerLocation,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TextStyle {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.background_color.is_empty() {
                state.serialize_entry("backgroundColor", &self.background_color)?;
            }
            if !self.text_color.is_empty() {
                state.serialize_entry("textColor", &self.text_color)?;
            }
            if !wkt::internal::is_default(&self.horizontal_alignment) {
                state.serialize_entry("horizontalAlignment", &self.horizontal_alignment)?;
            }
            if !wkt::internal::is_default(&self.vertical_alignment) {
                state.serialize_entry("verticalAlignment", &self.vertical_alignment)?;
            }
            if !wkt::internal::is_default(&self.padding) {
                state.serialize_entry("padding", &self.padding)?;
            }
            if !wkt::internal::is_default(&self.font_size) {
                state.serialize_entry("fontSize", &self.font_size)?;
            }
            if !wkt::internal::is_default(&self.pointer_location) {
                state.serialize_entry("pointerLocation", &self.pointer_location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TextStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TextStyle");
            debug_struct.field("background_color", &self.background_color);
            debug_struct.field("text_color", &self.text_color);
            debug_struct.field("horizontal_alignment", &self.horizontal_alignment);
            debug_struct.field("vertical_alignment", &self.vertical_alignment);
            debug_struct.field("padding", &self.padding);
            debug_struct.field("font_size", &self.font_size);
            debug_struct.field("pointer_location", &self.pointer_location);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [TextStyle].
    pub mod text_style {
        #[allow(unused_imports)]
        use super::*;

        /// The horizontal alignment of both the title and content on a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum HorizontalAlignment {
            /// No horizontal alignment specified, will default to H_LEFT
            Unspecified,
            /// Left-align
            HLeft,
            /// Center-align
            HCenter,
            /// Right-align
            HRight,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [HorizontalAlignment::value] or
            /// [HorizontalAlignment::name].
            UnknownValue(horizontal_alignment::UnknownValue),
        }

        #[doc(hidden)]
        pub mod horizontal_alignment {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl HorizontalAlignment {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::HLeft => std::option::Option::Some(1),
                    Self::HCenter => std::option::Option::Some(2),
                    Self::HRight => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("HORIZONTAL_ALIGNMENT_UNSPECIFIED")
                    }
                    Self::HLeft => std::option::Option::Some("H_LEFT"),
                    Self::HCenter => std::option::Option::Some("H_CENTER"),
                    Self::HRight => std::option::Option::Some("H_RIGHT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for HorizontalAlignment {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for HorizontalAlignment {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for HorizontalAlignment {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::HLeft,
                    2 => Self::HCenter,
                    3 => Self::HRight,
                    _ => Self::UnknownValue(horizontal_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for HorizontalAlignment {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => Self::Unspecified,
                    "H_LEFT" => Self::HLeft,
                    "H_CENTER" => Self::HCenter,
                    "H_RIGHT" => Self::HRight,
                    _ => Self::UnknownValue(horizontal_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for HorizontalAlignment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::HLeft => serializer.serialize_i32(1),
                    Self::HCenter => serializer.serialize_i32(2),
                    Self::HRight => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for HorizontalAlignment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(
                    wkt::internal::EnumVisitor::<HorizontalAlignment>::new(
                        ".google.monitoring.dashboard.v1.Text.TextStyle.HorizontalAlignment",
                    ),
                )
            }
        }

        /// The vertical alignment of both the title and content on a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum VerticalAlignment {
            /// No vertical alignment specified, will default to V_TOP
            Unspecified,
            /// Top-align
            VTop,
            /// Center-align
            VCenter,
            /// Bottom-align
            VBottom,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [VerticalAlignment::value] or
            /// [VerticalAlignment::name].
            UnknownValue(vertical_alignment::UnknownValue),
        }

        #[doc(hidden)]
        pub mod vertical_alignment {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl VerticalAlignment {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::VTop => std::option::Option::Some(1),
                    Self::VCenter => std::option::Option::Some(2),
                    Self::VBottom => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("VERTICAL_ALIGNMENT_UNSPECIFIED")
                    }
                    Self::VTop => std::option::Option::Some("V_TOP"),
                    Self::VCenter => std::option::Option::Some("V_CENTER"),
                    Self::VBottom => std::option::Option::Some("V_BOTTOM"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for VerticalAlignment {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for VerticalAlignment {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for VerticalAlignment {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::VTop,
                    2 => Self::VCenter,
                    3 => Self::VBottom,
                    _ => Self::UnknownValue(vertical_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for VerticalAlignment {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VERTICAL_ALIGNMENT_UNSPECIFIED" => Self::Unspecified,
                    "V_TOP" => Self::VTop,
                    "V_CENTER" => Self::VCenter,
                    "V_BOTTOM" => Self::VBottom,
                    _ => Self::UnknownValue(vertical_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for VerticalAlignment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::VTop => serializer.serialize_i32(1),
                    Self::VCenter => serializer.serialize_i32(2),
                    Self::VBottom => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for VerticalAlignment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<VerticalAlignment>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.VerticalAlignment",
                ))
            }
        }

        /// Specifies padding size around a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PaddingSize {
            /// No padding size specified, will default to P_EXTRA_SMALL
            Unspecified,
            /// Extra small padding
            PExtraSmall,
            /// Small padding
            PSmall,
            /// Medium padding
            PMedium,
            /// Large padding
            PLarge,
            /// Extra large padding
            PExtraLarge,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PaddingSize::value] or
            /// [PaddingSize::name].
            UnknownValue(padding_size::UnknownValue),
        }

        #[doc(hidden)]
        pub mod padding_size {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PaddingSize {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::PExtraSmall => std::option::Option::Some(1),
                    Self::PSmall => std::option::Option::Some(2),
                    Self::PMedium => std::option::Option::Some(3),
                    Self::PLarge => std::option::Option::Some(4),
                    Self::PExtraLarge => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PADDING_SIZE_UNSPECIFIED"),
                    Self::PExtraSmall => std::option::Option::Some("P_EXTRA_SMALL"),
                    Self::PSmall => std::option::Option::Some("P_SMALL"),
                    Self::PMedium => std::option::Option::Some("P_MEDIUM"),
                    Self::PLarge => std::option::Option::Some("P_LARGE"),
                    Self::PExtraLarge => std::option::Option::Some("P_EXTRA_LARGE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PaddingSize {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PaddingSize {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PaddingSize {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::PExtraSmall,
                    2 => Self::PSmall,
                    3 => Self::PMedium,
                    4 => Self::PLarge,
                    5 => Self::PExtraLarge,
                    _ => Self::UnknownValue(padding_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PaddingSize {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PADDING_SIZE_UNSPECIFIED" => Self::Unspecified,
                    "P_EXTRA_SMALL" => Self::PExtraSmall,
                    "P_SMALL" => Self::PSmall,
                    "P_MEDIUM" => Self::PMedium,
                    "P_LARGE" => Self::PLarge,
                    "P_EXTRA_LARGE" => Self::PExtraLarge,
                    _ => Self::UnknownValue(padding_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PaddingSize {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::PExtraSmall => serializer.serialize_i32(1),
                    Self::PSmall => serializer.serialize_i32(2),
                    Self::PMedium => serializer.serialize_i32(3),
                    Self::PLarge => serializer.serialize_i32(4),
                    Self::PExtraLarge => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PaddingSize {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PaddingSize>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.PaddingSize",
                ))
            }
        }

        /// Specifies a font size for the title and content of a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FontSize {
            /// No font size specified, will default to FS_LARGE
            Unspecified,
            /// Extra small font size
            FsExtraSmall,
            /// Small font size
            FsSmall,
            /// Medium font size
            FsMedium,
            /// Large font size
            FsLarge,
            /// Extra large font size
            FsExtraLarge,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FontSize::value] or
            /// [FontSize::name].
            UnknownValue(font_size::UnknownValue),
        }

        #[doc(hidden)]
        pub mod font_size {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FontSize {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::FsExtraSmall => std::option::Option::Some(1),
                    Self::FsSmall => std::option::Option::Some(2),
                    Self::FsMedium => std::option::Option::Some(3),
                    Self::FsLarge => std::option::Option::Some(4),
                    Self::FsExtraLarge => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FONT_SIZE_UNSPECIFIED"),
                    Self::FsExtraSmall => std::option::Option::Some("FS_EXTRA_SMALL"),
                    Self::FsSmall => std::option::Option::Some("FS_SMALL"),
                    Self::FsMedium => std::option::Option::Some("FS_MEDIUM"),
                    Self::FsLarge => std::option::Option::Some("FS_LARGE"),
                    Self::FsExtraLarge => std::option::Option::Some("FS_EXTRA_LARGE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FontSize {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FontSize {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FontSize {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::FsExtraSmall,
                    2 => Self::FsSmall,
                    3 => Self::FsMedium,
                    4 => Self::FsLarge,
                    5 => Self::FsExtraLarge,
                    _ => Self::UnknownValue(font_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FontSize {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FONT_SIZE_UNSPECIFIED" => Self::Unspecified,
                    "FS_EXTRA_SMALL" => Self::FsExtraSmall,
                    "FS_SMALL" => Self::FsSmall,
                    "FS_MEDIUM" => Self::FsMedium,
                    "FS_LARGE" => Self::FsLarge,
                    "FS_EXTRA_LARGE" => Self::FsExtraLarge,
                    _ => Self::UnknownValue(font_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FontSize {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::FsExtraSmall => serializer.serialize_i32(1),
                    Self::FsSmall => serializer.serialize_i32(2),
                    Self::FsMedium => serializer.serialize_i32(3),
                    Self::FsLarge => serializer.serialize_i32(4),
                    Self::FsExtraLarge => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FontSize {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FontSize>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.FontSize",
                ))
            }
        }

        /// Specifies where a visual pointer is placed on a text widget (also
        /// sometimes called a "tail")
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PointerLocation {
            /// No visual pointer
            Unspecified,
            /// Placed in the middle of the top of the widget
            PlTop,
            /// Placed in the middle of the right side of the widget
            PlRight,
            /// Placed in the middle of the bottom of the widget
            PlBottom,
            /// Placed in the middle of the left side of the widget
            PlLeft,
            /// Placed on the left side of the top of the widget
            PlTopLeft,
            /// Placed on the right side of the top of the widget
            PlTopRight,
            /// Placed on the top of the right side of the widget
            PlRightTop,
            /// Placed on the bottom of the right side of the widget
            PlRightBottom,
            /// Placed on the right side of the bottom of the widget
            PlBottomRight,
            /// Placed on the left side of the bottom of the widget
            PlBottomLeft,
            /// Placed on the bottom of the left side of the widget
            PlLeftBottom,
            /// Placed on the top of the left side of the widget
            PlLeftTop,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PointerLocation::value] or
            /// [PointerLocation::name].
            UnknownValue(pointer_location::UnknownValue),
        }

        #[doc(hidden)]
        pub mod pointer_location {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PointerLocation {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::PlTop => std::option::Option::Some(1),
                    Self::PlRight => std::option::Option::Some(2),
                    Self::PlBottom => std::option::Option::Some(3),
                    Self::PlLeft => std::option::Option::Some(4),
                    Self::PlTopLeft => std::option::Option::Some(5),
                    Self::PlTopRight => std::option::Option::Some(6),
                    Self::PlRightTop => std::option::Option::Some(7),
                    Self::PlRightBottom => std::option::Option::Some(8),
                    Self::PlBottomRight => std::option::Option::Some(9),
                    Self::PlBottomLeft => std::option::Option::Some(10),
                    Self::PlLeftBottom => std::option::Option::Some(11),
                    Self::PlLeftTop => std::option::Option::Some(12),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("POINTER_LOCATION_UNSPECIFIED"),
                    Self::PlTop => std::option::Option::Some("PL_TOP"),
                    Self::PlRight => std::option::Option::Some("PL_RIGHT"),
                    Self::PlBottom => std::option::Option::Some("PL_BOTTOM"),
                    Self::PlLeft => std::option::Option::Some("PL_LEFT"),
                    Self::PlTopLeft => std::option::Option::Some("PL_TOP_LEFT"),
                    Self::PlTopRight => std::option::Option::Some("PL_TOP_RIGHT"),
                    Self::PlRightTop => std::option::Option::Some("PL_RIGHT_TOP"),
                    Self::PlRightBottom => std::option::Option::Some("PL_RIGHT_BOTTOM"),
                    Self::PlBottomRight => std::option::Option::Some("PL_BOTTOM_RIGHT"),
                    Self::PlBottomLeft => std::option::Option::Some("PL_BOTTOM_LEFT"),
                    Self::PlLeftBottom => std::option::Option::Some("PL_LEFT_BOTTOM"),
                    Self::PlLeftTop => std::option::Option::Some("PL_LEFT_TOP"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PointerLocation {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PointerLocation {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PointerLocation {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::PlTop,
                    2 => Self::PlRight,
                    3 => Self::PlBottom,
                    4 => Self::PlLeft,
                    5 => Self::PlTopLeft,
                    6 => Self::PlTopRight,
                    7 => Self::PlRightTop,
                    8 => Self::PlRightBottom,
                    9 => Self::PlBottomRight,
                    10 => Self::PlBottomLeft,
                    11 => Self::PlLeftBottom,
                    12 => Self::PlLeftTop,
                    _ => Self::UnknownValue(pointer_location::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PointerLocation {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "POINTER_LOCATION_UNSPECIFIED" => Self::Unspecified,
                    "PL_TOP" => Self::PlTop,
                    "PL_RIGHT" => Self::PlRight,
                    "PL_BOTTOM" => Self::PlBottom,
                    "PL_LEFT" => Self::PlLeft,
                    "PL_TOP_LEFT" => Self::PlTopLeft,
                    "PL_TOP_RIGHT" => Self::PlTopRight,
                    "PL_RIGHT_TOP" => Self::PlRightTop,
                    "PL_RIGHT_BOTTOM" => Self::PlRightBottom,
                    "PL_BOTTOM_RIGHT" => Self::PlBottomRight,
                    "PL_BOTTOM_LEFT" => Self::PlBottomLeft,
                    "PL_LEFT_BOTTOM" => Self::PlLeftBottom,
                    "PL_LEFT_TOP" => Self::PlLeftTop,
                    _ => Self::UnknownValue(pointer_location::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PointerLocation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::PlTop => serializer.serialize_i32(1),
                    Self::PlRight => serializer.serialize_i32(2),
                    Self::PlBottom => serializer.serialize_i32(3),
                    Self::PlLeft => serializer.serialize_i32(4),
                    Self::PlTopLeft => serializer.serialize_i32(5),
                    Self::PlTopRight => serializer.serialize_i32(6),
                    Self::PlRightTop => serializer.serialize_i32(7),
                    Self::PlRightBottom => serializer.serialize_i32(8),
                    Self::PlBottomRight => serializer.serialize_i32(9),
                    Self::PlBottomLeft => serializer.serialize_i32(10),
                    Self::PlLeftBottom => serializer.serialize_i32(11),
                    Self::PlLeftTop => serializer.serialize_i32(12),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PointerLocation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PointerLocation>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.PointerLocation",
                ))
            }
        }
    }

    /// The format type of the text content.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Format {
        /// Format is unspecified. Defaults to MARKDOWN.
        Unspecified,
        /// The text contains Markdown formatting.
        Markdown,
        /// The text contains no special formatting.
        Raw,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Format::value] or
        /// [Format::name].
        UnknownValue(format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Format {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Markdown => std::option::Option::Some(1),
                Self::Raw => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                Self::Markdown => std::option::Option::Some("MARKDOWN"),
                Self::Raw => std::option::Option::Some("RAW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Format {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Format {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Format {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Markdown,
                2 => Self::Raw,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Format {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FORMAT_UNSPECIFIED" => Self::Unspecified,
                "MARKDOWN" => Self::Markdown,
                "RAW" => Self::Raw,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Format {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Markdown => serializer.serialize_i32(1),
                Self::Raw => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Format {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                ".google.monitoring.dashboard.v1.Text.Format",
            ))
        }
    }
}

/// Widget contains a single dashboard component and configuration of how to
/// present the component in the dashboard.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Widget {
    /// Optional. The title of the widget.
    pub title: std::string::String,

    /// Optional. The widget id. Ids may be made up of alphanumerics, dashes and
    /// underscores. Widget ids are optional.
    pub id: std::string::String,

    /// Content defines the component used to populate the widget.
    pub content: std::option::Option<crate::model::widget::Content>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Widget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::Widget::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Widget::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Widget::content].
    ///
    /// Note that all the setters affecting `content` are mutually
    /// exclusive.
    pub fn set_content<
        T: std::convert::Into<std::option::Option<crate::model::widget::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `XyChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn xy_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::XyChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::XyChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `XyChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_xy_chart<T: std::convert::Into<std::boxed::Box<crate::model::XyChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::XyChart(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Scorecard`, `None` if the field is not set or
    /// holds a different branch.
    pub fn scorecard(&self) -> std::option::Option<&std::boxed::Box<crate::model::Scorecard>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Scorecard(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Scorecard`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_scorecard<T: std::convert::Into<std::boxed::Box<crate::model::Scorecard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::Scorecard(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::boxed::Box<crate::model::Text>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::boxed::Box<crate::model::Text>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::Text(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Blank`, `None` if the field is not set or
    /// holds a different branch.
    pub fn blank(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Blank(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Blank`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_blank<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::Blank(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `AlertChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alert_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::AlertChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::AlertChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `AlertChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_alert_chart<T: std::convert::Into<std::boxed::Box<crate::model::AlertChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::AlertChart(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `TimeSeriesTable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_table(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesTable>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::TimeSeriesTable(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `TimeSeriesTable`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_time_series_table<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::TimeSeriesTable(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `CollapsibleGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collapsible_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CollapsibleGroup>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::CollapsibleGroup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `CollapsibleGroup`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_collapsible_group<
        T: std::convert::Into<std::boxed::Box<crate::model::CollapsibleGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::CollapsibleGroup(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `LogsPanel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn logs_panel(&self) -> std::option::Option<&std::boxed::Box<crate::model::LogsPanel>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::LogsPanel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `LogsPanel`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_logs_panel<T: std::convert::Into<std::boxed::Box<crate::model::LogsPanel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::LogsPanel(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `IncidentList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn incident_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IncidentList>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::IncidentList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `IncidentList`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_incident_list<T: std::convert::Into<std::boxed::Box<crate::model::IncidentList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::IncidentList(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `PieChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pie_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::PieChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::PieChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `PieChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_pie_chart<T: std::convert::Into<std::boxed::Box<crate::model::PieChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::PieChart(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `ErrorReportingPanel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error_reporting_panel(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ErrorReportingPanel>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::ErrorReportingPanel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `ErrorReportingPanel`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_error_reporting_panel<
        T: std::convert::Into<std::boxed::Box<crate::model::ErrorReportingPanel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::ErrorReportingPanel(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `SectionHeader`, `None` if the field is not set or
    /// holds a different branch.
    pub fn section_header(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SectionHeader>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::SectionHeader(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `SectionHeader`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_section_header<
        T: std::convert::Into<std::boxed::Box<crate::model::SectionHeader>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::SectionHeader(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `SingleViewGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_view_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleViewGroup>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::SingleViewGroup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `SingleViewGroup`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_single_view_group<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleViewGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::SingleViewGroup(v.into()));
        self
    }
}

impl wkt::message::Message for Widget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Widget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Widget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __xy_chart,
            __scorecard,
            __text,
            __blank,
            __alert_chart,
            __time_series_table,
            __collapsible_group,
            __logs_panel,
            __incident_list,
            __pie_chart,
            __error_reporting_panel,
            __section_header,
            __single_view_group,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Widget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "xyChart" => Ok(__FieldTag::__xy_chart),
                            "xy_chart" => Ok(__FieldTag::__xy_chart),
                            "scorecard" => Ok(__FieldTag::__scorecard),
                            "text" => Ok(__FieldTag::__text),
                            "blank" => Ok(__FieldTag::__blank),
                            "alertChart" => Ok(__FieldTag::__alert_chart),
                            "alert_chart" => Ok(__FieldTag::__alert_chart),
                            "timeSeriesTable" => Ok(__FieldTag::__time_series_table),
                            "time_series_table" => Ok(__FieldTag::__time_series_table),
                            "collapsibleGroup" => Ok(__FieldTag::__collapsible_group),
                            "collapsible_group" => Ok(__FieldTag::__collapsible_group),
                            "logsPanel" => Ok(__FieldTag::__logs_panel),
                            "logs_panel" => Ok(__FieldTag::__logs_panel),
                            "incidentList" => Ok(__FieldTag::__incident_list),
                            "incident_list" => Ok(__FieldTag::__incident_list),
                            "pieChart" => Ok(__FieldTag::__pie_chart),
                            "pie_chart" => Ok(__FieldTag::__pie_chart),
                            "errorReportingPanel" => Ok(__FieldTag::__error_reporting_panel),
                            "error_reporting_panel" => Ok(__FieldTag::__error_reporting_panel),
                            "sectionHeader" => Ok(__FieldTag::__section_header),
                            "section_header" => Ok(__FieldTag::__section_header),
                            "singleViewGroup" => Ok(__FieldTag::__single_view_group),
                            "single_view_group" => Ok(__FieldTag::__single_view_group),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Widget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Widget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__xy_chart => {
                            if !fields.insert(__FieldTag::__xy_chart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for xy_chart",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.xy_chart, latest field was xyChart",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(
                                    crate::model::widget::Content::XyChart(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::XyChart>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__scorecard => {
                            if !fields.insert(__FieldTag::__scorecard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scorecard",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.scorecard, latest field was scorecard",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::Scorecard(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Scorecard>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.text, latest field was text",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(
                                    crate::model::widget::Content::Text(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Text>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__blank => {
                            if !fields.insert(__FieldTag::__blank) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blank",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.blank, latest field was blank",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::Blank(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__alert_chart => {
                            if !fields.insert(__FieldTag::__alert_chart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alert_chart",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.alert_chart, latest field was alertChart",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::AlertChart(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AlertChart>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__time_series_table => {
                            if !fields.insert(__FieldTag::__time_series_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_table",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.time_series_table, latest field was timeSeriesTable",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::TimeSeriesTable(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeSeriesTable>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__collapsible_group => {
                            if !fields.insert(__FieldTag::__collapsible_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collapsible_group",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.collapsible_group, latest field was collapsibleGroup",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::CollapsibleGroup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CollapsibleGroup>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__logs_panel => {
                            if !fields.insert(__FieldTag::__logs_panel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logs_panel",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.logs_panel, latest field was logsPanel",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::LogsPanel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LogsPanel>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__incident_list => {
                            if !fields.insert(__FieldTag::__incident_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incident_list",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.incident_list, latest field was incidentList",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::IncidentList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IncidentList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pie_chart => {
                            if !fields.insert(__FieldTag::__pie_chart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pie_chart",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.pie_chart, latest field was pieChart",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(crate::model::widget::Content::PieChart(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PieChart>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__error_reporting_panel => {
                            if !fields.insert(__FieldTag::__error_reporting_panel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_reporting_panel",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.error_reporting_panel, latest field was errorReportingPanel",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::ErrorReportingPanel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ErrorReportingPanel>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__section_header => {
                            if !fields.insert(__FieldTag::__section_header) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for section_header",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.section_header, latest field was sectionHeader",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::SectionHeader(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SectionHeader>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__single_view_group => {
                            if !fields.insert(__FieldTag::__single_view_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_view_group",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.single_view_group, latest field was singleViewGroup",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::SingleViewGroup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SingleViewGroup>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Widget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if let Some(value) = self.xy_chart() {
            state.serialize_entry("xyChart", value)?;
        }
        if let Some(value) = self.scorecard() {
            state.serialize_entry("scorecard", value)?;
        }
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.blank() {
            state.serialize_entry("blank", value)?;
        }
        if let Some(value) = self.alert_chart() {
            state.serialize_entry("alertChart", value)?;
        }
        if let Some(value) = self.time_series_table() {
            state.serialize_entry("timeSeriesTable", value)?;
        }
        if let Some(value) = self.collapsible_group() {
            state.serialize_entry("collapsibleGroup", value)?;
        }
        if let Some(value) = self.logs_panel() {
            state.serialize_entry("logsPanel", value)?;
        }
        if let Some(value) = self.incident_list() {
            state.serialize_entry("incidentList", value)?;
        }
        if let Some(value) = self.pie_chart() {
            state.serialize_entry("pieChart", value)?;
        }
        if let Some(value) = self.error_reporting_panel() {
            state.serialize_entry("errorReportingPanel", value)?;
        }
        if let Some(value) = self.section_header() {
            state.serialize_entry("sectionHeader", value)?;
        }
        if let Some(value) = self.single_view_group() {
            state.serialize_entry("singleViewGroup", value)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Widget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Widget");
        debug_struct.field("title", &self.title);
        debug_struct.field("id", &self.id);
        debug_struct.field("content", &self.content);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Widget].
pub mod widget {
    #[allow(unused_imports)]
    use super::*;

    /// Content defines the component used to populate the widget.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Content {
        /// A chart of time series data.
        XyChart(std::boxed::Box<crate::model::XyChart>),
        /// A scorecard summarizing time series data.
        Scorecard(std::boxed::Box<crate::model::Scorecard>),
        /// A raw string or markdown displaying textual content.
        Text(std::boxed::Box<crate::model::Text>),
        /// A blank space.
        Blank(std::boxed::Box<wkt::Empty>),
        /// A chart of alert policy data.
        AlertChart(std::boxed::Box<crate::model::AlertChart>),
        /// A widget that displays time series data in a tabular format.
        TimeSeriesTable(std::boxed::Box<crate::model::TimeSeriesTable>),
        /// A widget that groups the other widgets. All widgets that are within
        /// the area spanned by the grouping widget are considered member widgets.
        CollapsibleGroup(std::boxed::Box<crate::model::CollapsibleGroup>),
        /// A widget that shows a stream of logs.
        LogsPanel(std::boxed::Box<crate::model::LogsPanel>),
        /// A widget that shows list of incidents.
        IncidentList(std::boxed::Box<crate::model::IncidentList>),
        /// A widget that displays timeseries data as a pie chart.
        PieChart(std::boxed::Box<crate::model::PieChart>),
        /// A widget that displays a list of error groups.
        ErrorReportingPanel(std::boxed::Box<crate::model::ErrorReportingPanel>),
        /// A widget that defines a section header for easier navigation of the
        /// dashboard.
        SectionHeader(std::boxed::Box<crate::model::SectionHeader>),
        /// A widget that groups the other widgets by using a dropdown menu.
        SingleViewGroup(std::boxed::Box<crate::model::SingleViewGroup>),
    }
}

/// A chart that displays data on a 2D (X and Y axes) plane.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct XyChart {
    /// Required. The data displayed in this chart.
    pub data_sets: std::vec::Vec<crate::model::xy_chart::DataSet>,

    /// The duration used to display a comparison chart. A comparison chart
    /// simultaneously shows values from two similar-length time periods
    /// (e.g., week-over-week metrics).
    /// The duration must be positive, and it can only be applied to charts with
    /// data sets of LINE plot type.
    pub timeshift_duration: std::option::Option<wkt::Duration>,

    /// Threshold lines drawn horizontally across the chart.
    pub thresholds: std::vec::Vec<crate::model::Threshold>,

    /// The properties applied to the x-axis.
    pub x_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// The properties applied to the y-axis.
    pub y_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// The properties applied to the y2-axis.
    pub y2_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// Display options for the chart.
    pub chart_options: std::option::Option<crate::model::ChartOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl XyChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sets][crate::model::XyChart::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::xy_chart::DataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timeshift_duration][crate::model::XyChart::timeshift_duration].
    pub fn set_timeshift_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeshift_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeshift_duration][crate::model::XyChart::timeshift_duration].
    pub fn set_or_clear_timeshift_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeshift_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [thresholds][crate::model::XyChart::thresholds].
    pub fn set_thresholds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Threshold>,
    {
        use std::iter::Iterator;
        self.thresholds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [x_axis][crate::model::XyChart::x_axis].
    pub fn set_x_axis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::xy_chart::Axis>,
    {
        self.x_axis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [x_axis][crate::model::XyChart::x_axis].
    pub fn set_or_clear_x_axis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::xy_chart::Axis>,
    {
        self.x_axis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [y_axis][crate::model::XyChart::y_axis].
    pub fn set_y_axis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::xy_chart::Axis>,
    {
        self.y_axis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [y_axis][crate::model::XyChart::y_axis].
    pub fn set_or_clear_y_axis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::xy_chart::Axis>,
    {
        self.y_axis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [y2_axis][crate::model::XyChart::y2_axis].
    pub fn set_y2_axis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::xy_chart::Axis>,
    {
        self.y2_axis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [y2_axis][crate::model::XyChart::y2_axis].
    pub fn set_or_clear_y2_axis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::xy_chart::Axis>,
    {
        self.y2_axis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [chart_options][crate::model::XyChart::chart_options].
    pub fn set_chart_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ChartOptions>,
    {
        self.chart_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [chart_options][crate::model::XyChart::chart_options].
    pub fn set_or_clear_chart_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ChartOptions>,
    {
        self.chart_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for XyChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.XyChart"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for XyChart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sets,
            __timeshift_duration,
            __thresholds,
            __x_axis,
            __y_axis,
            __y2_axis,
            __chart_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for XyChart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSets" => Ok(__FieldTag::__data_sets),
                            "data_sets" => Ok(__FieldTag::__data_sets),
                            "timeshiftDuration" => Ok(__FieldTag::__timeshift_duration),
                            "timeshift_duration" => Ok(__FieldTag::__timeshift_duration),
                            "thresholds" => Ok(__FieldTag::__thresholds),
                            "xAxis" => Ok(__FieldTag::__x_axis),
                            "x_axis" => Ok(__FieldTag::__x_axis),
                            "yAxis" => Ok(__FieldTag::__y_axis),
                            "y_axis" => Ok(__FieldTag::__y_axis),
                            "y2Axis" => Ok(__FieldTag::__y2_axis),
                            "y2_axis" => Ok(__FieldTag::__y2_axis),
                            "chartOptions" => Ok(__FieldTag::__chart_options),
                            "chart_options" => Ok(__FieldTag::__chart_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = XyChart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct XyChart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sets => {
                            if !fields.insert(__FieldTag::__data_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sets",
                                ));
                            }
                            result.data_sets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::xy_chart::DataSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeshift_duration => {
                            if !fields.insert(__FieldTag::__timeshift_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeshift_duration",
                                ));
                            }
                            result.timeshift_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__thresholds => {
                            if !fields.insert(__FieldTag::__thresholds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for thresholds",
                                ));
                            }
                            result.thresholds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Threshold>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__x_axis => {
                            if !fields.insert(__FieldTag::__x_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x_axis",
                                ));
                            }
                            result.x_axis = map
                                .next_value::<std::option::Option<crate::model::xy_chart::Axis>>(
                                )?;
                        }
                        __FieldTag::__y_axis => {
                            if !fields.insert(__FieldTag::__y_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y_axis",
                                ));
                            }
                            result.y_axis = map
                                .next_value::<std::option::Option<crate::model::xy_chart::Axis>>(
                                )?;
                        }
                        __FieldTag::__y2_axis => {
                            if !fields.insert(__FieldTag::__y2_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y2_axis",
                                ));
                            }
                            result.y2_axis = map
                                .next_value::<std::option::Option<crate::model::xy_chart::Axis>>(
                                )?;
                        }
                        __FieldTag::__chart_options => {
                            if !fields.insert(__FieldTag::__chart_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chart_options",
                                ));
                            }
                            result.chart_options = map
                                .next_value::<std::option::Option<crate::model::ChartOptions>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for XyChart {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_sets.is_empty() {
            state.serialize_entry("dataSets", &self.data_sets)?;
        }
        if self.timeshift_duration.is_some() {
            state.serialize_entry("timeshiftDuration", &self.timeshift_duration)?;
        }
        if !self.thresholds.is_empty() {
            state.serialize_entry("thresholds", &self.thresholds)?;
        }
        if self.x_axis.is_some() {
            state.serialize_entry("xAxis", &self.x_axis)?;
        }
        if self.y_axis.is_some() {
            state.serialize_entry("yAxis", &self.y_axis)?;
        }
        if self.y2_axis.is_some() {
            state.serialize_entry("y2Axis", &self.y2_axis)?;
        }
        if self.chart_options.is_some() {
            state.serialize_entry("chartOptions", &self.chart_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for XyChart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("XyChart");
        debug_struct.field("data_sets", &self.data_sets);
        debug_struct.field("timeshift_duration", &self.timeshift_duration);
        debug_struct.field("thresholds", &self.thresholds);
        debug_struct.field("x_axis", &self.x_axis);
        debug_struct.field("y_axis", &self.y_axis);
        debug_struct.field("y2_axis", &self.y2_axis);
        debug_struct.field("chart_options", &self.chart_options);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [XyChart].
pub mod xy_chart {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition with charting options.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// How this data should be plotted on the chart.
        pub plot_type: crate::model::xy_chart::data_set::PlotType,

        /// A template string for naming `TimeSeries` in the resulting data set.
        /// This should be a string with interpolations of the form `${label_name}`,
        /// which will resolve to the label's value.
        pub legend_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        /// Optional. The target axis to use for plotting the metric.
        pub target_axis: crate::model::xy_chart::data_set::TargetAxis,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::xy_chart::DataSet::time_series_query].
        pub fn set_time_series_query<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TimeSeriesQuery>,
        {
            self.time_series_query = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time_series_query][crate::model::xy_chart::DataSet::time_series_query].
        pub fn set_or_clear_time_series_query<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TimeSeriesQuery>,
        {
            self.time_series_query = v.map(|x| x.into());
            self
        }

        /// Sets the value of [plot_type][crate::model::xy_chart::DataSet::plot_type].
        pub fn set_plot_type<T: std::convert::Into<crate::model::xy_chart::data_set::PlotType>>(
            mut self,
            v: T,
        ) -> Self {
            self.plot_type = v.into();
            self
        }

        /// Sets the value of [legend_template][crate::model::xy_chart::DataSet::legend_template].
        pub fn set_legend_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.legend_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::xy_chart::DataSet::min_alignment_period].
        pub fn set_min_alignment_period<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_alignment_period][crate::model::xy_chart::DataSet::min_alignment_period].
        pub fn set_or_clear_min_alignment_period<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_alignment_period = v.map(|x| x.into());
            self
        }

        /// Sets the value of [target_axis][crate::model::xy_chart::DataSet::target_axis].
        pub fn set_target_axis<
            T: std::convert::Into<crate::model::xy_chart::data_set::TargetAxis>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target_axis = v.into();
            self
        }
    }

    impl wkt::message::Message for DataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.XyChart.DataSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time_series_query,
                __plot_type,
                __legend_template,
                __min_alignment_period,
                __target_axis,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                                "time_series_query" => Ok(__FieldTag::__time_series_query),
                                "plotType" => Ok(__FieldTag::__plot_type),
                                "plot_type" => Ok(__FieldTag::__plot_type),
                                "legendTemplate" => Ok(__FieldTag::__legend_template),
                                "legend_template" => Ok(__FieldTag::__legend_template),
                                "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                                "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                                "targetAxis" => Ok(__FieldTag::__target_axis),
                                "target_axis" => Ok(__FieldTag::__target_axis),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time_series_query => {
                                if !fields.insert(__FieldTag::__time_series_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_series_query",
                                    ));
                                }
                                result.time_series_query = map.next_value::<std::option::Option<crate::model::TimeSeriesQuery>>()?
                                    ;
                            }
                            __FieldTag::__plot_type => {
                                if !fields.insert(__FieldTag::__plot_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for plot_type",
                                    ));
                                }
                                result.plot_type =
                                    map.next_value::<std::option::Option<
                                        crate::model::xy_chart::data_set::PlotType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__legend_template => {
                                if !fields.insert(__FieldTag::__legend_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for legend_template",
                                    ));
                                }
                                result.legend_template = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__min_alignment_period => {
                                if !fields.insert(__FieldTag::__min_alignment_period) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_alignment_period",
                                    ));
                                }
                                result.min_alignment_period =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__target_axis => {
                                if !fields.insert(__FieldTag::__target_axis) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_axis",
                                    ));
                                }
                                result.target_axis = map
                                    .next_value::<std::option::Option<
                                        crate::model::xy_chart::data_set::TargetAxis,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.time_series_query.is_some() {
                state.serialize_entry("timeSeriesQuery", &self.time_series_query)?;
            }
            if !wkt::internal::is_default(&self.plot_type) {
                state.serialize_entry("plotType", &self.plot_type)?;
            }
            if !self.legend_template.is_empty() {
                state.serialize_entry("legendTemplate", &self.legend_template)?;
            }
            if self.min_alignment_period.is_some() {
                state.serialize_entry("minAlignmentPeriod", &self.min_alignment_period)?;
            }
            if !wkt::internal::is_default(&self.target_axis) {
                state.serialize_entry("targetAxis", &self.target_axis)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DataSet {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DataSet");
            debug_struct.field("time_series_query", &self.time_series_query);
            debug_struct.field("plot_type", &self.plot_type);
            debug_struct.field("legend_template", &self.legend_template);
            debug_struct.field("min_alignment_period", &self.min_alignment_period);
            debug_struct.field("target_axis", &self.target_axis);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [DataSet].
    pub mod data_set {
        #[allow(unused_imports)]
        use super::*;

        /// The types of plotting strategies for data sets.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PlotType {
            /// Plot type is unspecified. The view will default to `LINE`.
            Unspecified,
            /// The data is plotted as a set of lines (one line per series).
            Line,
            /// The data is plotted as a set of filled areas (one area per series),
            /// with the areas stacked vertically (the base of each area is the top of
            /// its predecessor, and the base of the first area is the x-axis). Since
            /// the areas do not overlap, each is filled with a different opaque color.
            StackedArea,
            /// The data is plotted as a set of rectangular boxes (one box per series),
            /// with the boxes stacked vertically (the base of each box is the top of
            /// its predecessor, and the base of the first box is the x-axis). Since
            /// the boxes do not overlap, each is filled with a different opaque color.
            StackedBar,
            /// The data is plotted as a heatmap. The series being plotted must have a
            /// `DISTRIBUTION` value type. The value of each bucket in the distribution
            /// is displayed as a color. This type is not currently available in the
            /// Stackdriver Monitoring application.
            Heatmap,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PlotType::value] or
            /// [PlotType::name].
            UnknownValue(plot_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod plot_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PlotType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Line => std::option::Option::Some(1),
                    Self::StackedArea => std::option::Option::Some(2),
                    Self::StackedBar => std::option::Option::Some(3),
                    Self::Heatmap => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PLOT_TYPE_UNSPECIFIED"),
                    Self::Line => std::option::Option::Some("LINE"),
                    Self::StackedArea => std::option::Option::Some("STACKED_AREA"),
                    Self::StackedBar => std::option::Option::Some("STACKED_BAR"),
                    Self::Heatmap => std::option::Option::Some("HEATMAP"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PlotType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PlotType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PlotType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Line,
                    2 => Self::StackedArea,
                    3 => Self::StackedBar,
                    4 => Self::Heatmap,
                    _ => Self::UnknownValue(plot_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PlotType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PLOT_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "LINE" => Self::Line,
                    "STACKED_AREA" => Self::StackedArea,
                    "STACKED_BAR" => Self::StackedBar,
                    "HEATMAP" => Self::Heatmap,
                    _ => Self::UnknownValue(plot_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PlotType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Line => serializer.serialize_i32(1),
                    Self::StackedArea => serializer.serialize_i32(2),
                    Self::StackedBar => serializer.serialize_i32(3),
                    Self::Heatmap => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PlotType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PlotType>::new(
                    ".google.monitoring.dashboard.v1.XyChart.DataSet.PlotType",
                ))
            }
        }

        /// An axis identifier.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TargetAxis {
            /// The target axis was not specified. Defaults to Y1.
            Unspecified,
            /// The y_axis (the right axis of chart).
            Y1,
            /// The y2_axis (the left axis of chart).
            Y2,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TargetAxis::value] or
            /// [TargetAxis::name].
            UnknownValue(target_axis::UnknownValue),
        }

        #[doc(hidden)]
        pub mod target_axis {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TargetAxis {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Y1 => std::option::Option::Some(1),
                    Self::Y2 => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TARGET_AXIS_UNSPECIFIED"),
                    Self::Y1 => std::option::Option::Some("Y1"),
                    Self::Y2 => std::option::Option::Some("Y2"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TargetAxis {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TargetAxis {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TargetAxis {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Y1,
                    2 => Self::Y2,
                    _ => Self::UnknownValue(target_axis::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TargetAxis {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TARGET_AXIS_UNSPECIFIED" => Self::Unspecified,
                    "Y1" => Self::Y1,
                    "Y2" => Self::Y2,
                    _ => Self::UnknownValue(target_axis::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TargetAxis {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Y1 => serializer.serialize_i32(1),
                    Self::Y2 => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TargetAxis {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetAxis>::new(
                    ".google.monitoring.dashboard.v1.XyChart.DataSet.TargetAxis",
                ))
            }
        }
    }

    /// A chart axis.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Axis {
        /// The label of the axis.
        pub label: std::string::String,

        /// The axis scale. By default, a linear scale is used.
        pub scale: crate::model::xy_chart::axis::Scale,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Axis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [label][crate::model::xy_chart::Axis::label].
        pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.label = v.into();
            self
        }

        /// Sets the value of [scale][crate::model::xy_chart::Axis::scale].
        pub fn set_scale<T: std::convert::Into<crate::model::xy_chart::axis::Scale>>(
            mut self,
            v: T,
        ) -> Self {
            self.scale = v.into();
            self
        }
    }

    impl wkt::message::Message for Axis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.XyChart.Axis"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Axis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __label,
                __scale,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Axis")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "label" => Ok(__FieldTag::__label),
                                "scale" => Ok(__FieldTag::__scale),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Axis;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Axis")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__label => {
                                if !fields.insert(__FieldTag::__label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for label",
                                    ));
                                }
                                result.label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__scale => {
                                if !fields.insert(__FieldTag::__scale) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scale",
                                    ));
                                }
                                result.scale = map.next_value::<std::option::Option<crate::model::xy_chart::axis::Scale>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Axis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.label.is_empty() {
                state.serialize_entry("label", &self.label)?;
            }
            if !wkt::internal::is_default(&self.scale) {
                state.serialize_entry("scale", &self.scale)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Axis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Axis");
            debug_struct.field("label", &self.label);
            debug_struct.field("scale", &self.scale);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Axis].
    pub mod axis {
        #[allow(unused_imports)]
        use super::*;

        /// Types of scales used in axes.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Scale {
            /// Scale is unspecified. The view will default to `LINEAR`.
            Unspecified,
            /// Linear scale.
            Linear,
            /// Logarithmic scale (base 10).
            Log10,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Scale::value] or
            /// [Scale::name].
            UnknownValue(scale::UnknownValue),
        }

        #[doc(hidden)]
        pub mod scale {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Scale {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Linear => std::option::Option::Some(1),
                    Self::Log10 => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SCALE_UNSPECIFIED"),
                    Self::Linear => std::option::Option::Some("LINEAR"),
                    Self::Log10 => std::option::Option::Some("LOG10"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Scale {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Scale {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Scale {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Linear,
                    2 => Self::Log10,
                    _ => Self::UnknownValue(scale::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Scale {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SCALE_UNSPECIFIED" => Self::Unspecified,
                    "LINEAR" => Self::Linear,
                    "LOG10" => Self::Log10,
                    _ => Self::UnknownValue(scale::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Scale {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Linear => serializer.serialize_i32(1),
                    Self::Log10 => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Scale {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scale>::new(
                    ".google.monitoring.dashboard.v1.XyChart.Axis.Scale",
                ))
            }
        }
    }
}

/// Options to control visual rendering of a chart.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ChartOptions {
    /// The chart mode.
    pub mode: crate::model::chart_options::Mode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChartOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::ChartOptions::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::chart_options::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for ChartOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ChartOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChartOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChartOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChartOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChartOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::chart_options::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChartOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ChartOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChartOptions");
        debug_struct.field("mode", &self.mode);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ChartOptions].
pub mod chart_options {
    #[allow(unused_imports)]
    use super::*;

    /// Chart mode options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode is unspecified. The view will default to `COLOR`.
        Unspecified,
        /// The chart distinguishes data series using different color. Line
        /// colors may get reused when there are many lines in the chart.
        Color,
        /// The chart uses the Stackdriver x-ray mode, in which each
        /// data set is plotted using the same semi-transparent color.
        XRay,
        /// The chart displays statistics such as average, median, 95th percentile,
        /// and more.
        Stats,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Color => std::option::Option::Some(1),
                Self::XRay => std::option::Option::Some(2),
                Self::Stats => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Color => std::option::Option::Some("COLOR"),
                Self::XRay => std::option::Option::Some("X_RAY"),
                Self::Stats => std::option::Option::Some("STATS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Color,
                2 => Self::XRay,
                3 => Self::Stats,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "COLOR" => Self::Color,
                "X_RAY" => Self::XRay,
                "STATS" => Self::Stats,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Color => serializer.serialize_i32(1),
                Self::XRay => serializer.serialize_i32(2),
                Self::Stats => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.monitoring.dashboard.v1.ChartOptions.Mode",
            ))
        }
    }
}

/// Defines the possible types of spark chart supported by the `Scorecard`.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SparkChartType {
    /// Not allowed in well-formed requests.
    Unspecified,
    /// The sparkline will be rendered as a small line chart.
    SparkLine,
    /// The sparkbar will be rendered as a small bar chart.
    SparkBar,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SparkChartType::value] or
    /// [SparkChartType::name].
    UnknownValue(spark_chart_type::UnknownValue),
}

#[doc(hidden)]
pub mod spark_chart_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SparkChartType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SparkLine => std::option::Option::Some(1),
            Self::SparkBar => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SPARK_CHART_TYPE_UNSPECIFIED"),
            Self::SparkLine => std::option::Option::Some("SPARK_LINE"),
            Self::SparkBar => std::option::Option::Some("SPARK_BAR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SparkChartType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SparkChartType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SparkChartType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::SparkLine,
            2 => Self::SparkBar,
            _ => Self::UnknownValue(spark_chart_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SparkChartType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SPARK_CHART_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SPARK_LINE" => Self::SparkLine,
            "SPARK_BAR" => Self::SparkBar,
            _ => Self::UnknownValue(spark_chart_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SparkChartType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SparkLine => serializer.serialize_i32(1),
            Self::SparkBar => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SparkChartType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SparkChartType>::new(
            ".google.monitoring.dashboard.v1.SparkChartType",
        ))
    }
}
