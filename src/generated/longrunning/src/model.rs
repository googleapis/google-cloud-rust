// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// This resource represents a long-running operation that is the result of a
/// network API call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Operation {
    /// The server-assigned name, which is only unique within the same service that
    /// originally returns it. If you use the default HTTP mapping, the
    /// `name` should be a resource name ending with `operations/{unique_id}`.
    pub name: std::string::String,

    /// Service-specific metadata associated with the operation.  It typically
    /// contains progress information and common metadata such as create time.
    /// Some services might not provide such metadata.  Any method that returns a
    /// long-running operation should document the metadata type, if any.
    pub metadata: std::option::Option<wkt::Any>,

    /// If the value is `false`, it means the operation is still in progress.
    /// If `true`, the operation is completed, and either `error` or `response` is
    /// available.
    pub done: bool,

    /// The operation result, which can be either an `error` or a valid `response`.
    /// If `done` == `false`, neither `error` nor `response` is set.
    /// If `done` == `true`, exactly one of `error` or `response` can be set.
    /// Some services might not provide the result.
    pub result: std::option::Option<crate::model::operation::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Operation::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::Operation::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [done][crate::model::Operation::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }

    /// Sets the value of [result][crate::model::Operation::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::operation::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::Operation::result]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::operation::Result::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::Operation::result]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(crate::model::operation::Result::Error(v.into()));
        self
    }

    /// The value of [result][crate::model::Operation::result]
    /// if it holds a `Response`, `None` if the field is not set or
    /// holds a different branch.
    pub fn response(&self) -> std::option::Option<&std::boxed::Box<wkt::Any>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::operation::Result::Response(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::Operation::result]
    /// to hold a `Response`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_response<T: std::convert::Into<std::boxed::Box<wkt::Any>>>(mut self, v: T) -> Self {
        self.result =
            std::option::Option::Some(crate::model::operation::Result::Response(v.into()));
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.Operation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Operation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __metadata,
            __done,
            __error,
            __response,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Operation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "done" => Ok(__FieldTag::__done),
                            "error" => Ok(__FieldTag::__error),
                            "response" => Ok(__FieldTag::__response),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Operation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Operation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done",
                                ));
                            }
                            result.done = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.longrunning.Operation.error, latest field was error",
                                ));
                            }
                            result.result =
                                std::option::Option::Some(
                                    crate::model::operation::Result::Error(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<rpc::model::Status>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__response => {
                            if !fields.insert(__FieldTag::__response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.longrunning.Operation.response, latest field was response",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::operation::Result::Response(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Any>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !wkt::internal::is_default(&self.done) {
            state.serialize_entry("done", &self.done)?;
        }
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if let Some(value) = self.response() {
            state.serialize_entry("response", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Operation");
        debug_struct.field("name", &self.name);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("done", &self.done);
        debug_struct.field("result", &self.result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// The operation result, which can be either an `error` or a valid `response`.
    /// If `done` == `false`, neither `error` nor `response` is set.
    /// If `done` == `true`, exactly one of `error` or `response` can be set.
    /// Some services might not provide the result.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// The error result of the operation in case of failure or cancellation.
        Error(std::boxed::Box<rpc::model::Status>),
        /// The normal, successful response of the operation.  If the original
        /// method returns no data on success, such as `Delete`, the response is
        /// `google.protobuf.Empty`.  If the original method is standard
        /// `Get`/`Create`/`Update`, the response should be the resource.  For other
        /// methods, the response should have the type `XxxResponse`, where `Xxx`
        /// is the original method name.  For example, if the original method name
        /// is `TakeSnapshot()`, the inferred response type is
        /// `TakeSnapshotResponse`.
        Response(std::boxed::Box<wkt::Any>),
    }
}

/// The request message for
/// [Operations.GetOperation][google.longrunning.Operations.GetOperation].
///
/// [google.longrunning.Operations.GetOperation]: crate::client::Operations::get_operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOperationRequest {
    /// The name of the operation resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.GetOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOperationRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request message for
/// [Operations.ListOperations][google.longrunning.Operations.ListOperations].
///
/// [google.longrunning.Operations.ListOperations]: crate::client::Operations::list_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOperationsRequest {
    /// The name of the operation's parent resource.
    pub name: std::string::String,

    /// The standard list filter.
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListOperationsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOperationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOperationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOperationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.ListOperationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOperationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOperationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOperationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOperationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOperationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOperationsRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response message for
/// [Operations.ListOperations][google.longrunning.Operations.ListOperations].
///
/// [google.longrunning.Operations.ListOperations]: crate::client::Operations::list_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOperationsResponse {
    /// A list of operations that matches the specified filter in the request.
    pub operations: std::vec::Vec<crate::model::Operation>,

    /// The standard List next-page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::ListOperationsResponse::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOperationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.ListOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOperationsResponse {
    type PageItem = crate::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOperationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOperationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operations" => Ok(__FieldTag::__operations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOperationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOperationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Operation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOperationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOperationsResponse");
        debug_struct.field("operations", &self.operations);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request message for
/// [Operations.CancelOperation][google.longrunning.Operations.CancelOperation].
///
/// [google.longrunning.Operations.CancelOperation]: crate::client::Operations::cancel_operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelOperationRequest {
    /// The name of the operation resource to be cancelled.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.CancelOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelOperationRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request message for
/// [Operations.DeleteOperation][google.longrunning.Operations.DeleteOperation].
///
/// [google.longrunning.Operations.DeleteOperation]: crate::client::Operations::delete_operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteOperationRequest {
    /// The name of the operation resource to be deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.DeleteOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteOperationRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request message for
/// [Operations.WaitOperation][google.longrunning.Operations.WaitOperation].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WaitOperationRequest {
    /// The name of the operation resource to wait on.
    pub name: std::string::String,

    /// The maximum duration to wait before timing out. If left blank, the wait
    /// will be at most the time permitted by the underlying HTTP/RPC protocol.
    /// If RPC context deadline is also specified, the shorter one will be used.
    pub timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WaitOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WaitOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::WaitOperationRequest::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::WaitOperationRequest::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WaitOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.WaitOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WaitOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WaitOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "timeout" => Ok(__FieldTag::__timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WaitOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WaitOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WaitOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WaitOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WaitOperationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("timeout", &self.timeout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A message representing the message types used by a long-running operation.
///
/// Example:
///
/// ```norust
/// rpc Export(ExportRequest) returns (google.longrunning.Operation) {
///   option (google.longrunning.operation_info) = {
///     response_type: "ExportResponse"
///     metadata_type: "ExportMetadata"
///   };
/// }
/// ```
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationInfo {
    /// Required. The message name of the primary return type for this
    /// long-running operation.
    /// This type will be used to deserialize the LRO's response.
    ///
    /// If the response is in a different package from the rpc, a fully-qualified
    /// message name must be used (e.g. `google.protobuf.Struct`).
    ///
    /// Note: Altering this value constitutes a breaking change.
    pub response_type: std::string::String,

    /// Required. The message name of the metadata type for this long-running
    /// operation.
    ///
    /// If the response is in a different package from the rpc, a fully-qualified
    /// message name must be used (e.g. `google.protobuf.Struct`).
    ///
    /// Note: Altering this value constitutes a breaking change.
    pub metadata_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_type][crate::model::OperationInfo::response_type].
    pub fn set_response_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [metadata_type][crate::model::OperationInfo::metadata_type].
    pub fn set_metadata_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metadata_type = v.into();
        self
    }
}

impl wkt::message::Message for OperationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.longrunning.OperationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_type,
            __metadata_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseType" => Ok(__FieldTag::__response_type),
                            "response_type" => Ok(__FieldTag::__response_type),
                            "metadataType" => Ok(__FieldTag::__metadata_type),
                            "metadata_type" => Ok(__FieldTag::__metadata_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_type => {
                            if !fields.insert(__FieldTag::__response_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_type",
                                ));
                            }
                            result.response_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata_type => {
                            if !fields.insert(__FieldTag::__metadata_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_type",
                                ));
                            }
                            result.metadata_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_type.is_empty() {
            state.serialize_entry("responseType", &self.response_type)?;
        }
        if !self.metadata_type.is_empty() {
            state.serialize_entry("metadataType", &self.metadata_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationInfo");
        debug_struct.field("response_type", &self.response_type);
        debug_struct.field("metadata_type", &self.metadata_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
